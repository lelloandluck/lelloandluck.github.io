<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git如何创建远程分支并提交文件</title>
      <link href="/2021/07/29/git-ru-he-chuang-jian-yuan-cheng-fen-zhi-bing-ti-jiao-wen-jian/"/>
      <url>/2021/07/29/git-ru-he-chuang-jian-yuan-cheng-fen-zhi-bing-ti-jiao-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>GIT (分布式版本控制系统) 编辑 Git是一款免费、开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。了解和掌握它的基本用法是每个it人员的必备技能，详细的用法网上资料特别多，这里我专门梳理下这个场景 - “创建远程分支并提交文件”，个人认为这个场景使用非常的普遍，它涵盖了git的常用命令并直观的体现了git的工作原理，掌握了它对我们后续深入学习git很有帮助。</p><p>Common Commands -</p><ol><li>让本地文件夹作为git的版本控制创库<br>$ Git init</li><li>创建新的分支：<br>$ Git branch branchName # 但依旧停留在当前分支<br>$ Git checkout -b branchName # 创建后并切换到该分支</li><li>删除分支<br>$ Git branch -d branName</li><li>切换到制定分支<br>$ Git checkout branchName</li><li>查看远程仓库信息及常用操作<br>git remote -v：                                查看远程仓库详细信息，可以看到仓库名称<br>git remote remove orign：                      删除orign仓库（如果把origin拼写成orign，删除错误名称仓库）<br>git remote add origin 仓库地址：                重新添加远程仓库地址<br>gti push -u origin master：                    提交到远程仓库的master主干<br>此命令可以帮助查看当前本地仓库与远程仓库的关联情况，-v 会列出远程仓库主机名称，网址等信息（origin通常是默认远程主机名称）</li><li>查看分支<br>查看本地分支<br>git branch, *号表示当前所在分支；git branch -v；git branch -vv，可以查看上流分支的名字；<br>查看所有远程分支<br>git branch -r，-r就是-remote；<br>查看所有本地分支与远程分支<br>git branch -a，-a就是-all；</li><li>关联本地仓库和远程仓库<br>$ git remote add origin <a href="https://github.com/lelloandluck/basicfiles_backup.git">https://github.com/lelloandluck/basicfiles_backup.git</a></li></ol><hr><p>Scenario -<br>    <strong>创建远程分支</strong>（请确保step#7 已关联，不然本地分支无法识别远程仓库，也就无法创建远程分支了）<br>    把新建分支push到远程服务器<br>    • $ git push origin localbranch:newbranch_remote</p><p>  删除远程分支<br>  • $ git push origin :newbranch_remote<br>    • $ git push origin –delete newbranch_remote<br>    • 增加要上传的文件到本地分支<br>    • $ git add .<br>    • $ git commit -m “description for commit purpose”</p><p><strong>Reference document -</strong><br>在我们第一次提交git的时候：<br><img src="/medias/gitOpper001.png" alt="截图1"><br>发现上面用了这个-u参数，也没作解释，特意搜索了下这个-u的用法，加了参数-u后，以后即可直接用git push 代替git push origin master<br>git push -u origin master</p><p><strong>对于经常更新的文件，如果我们需要备份它到远程仓库，就可以借用上面的方法来实现</strong> -</p><ol><li>建立远程仓库链接后</li><li>建立关联的远程分支</li><li>将更新的文件加入本地仓库</li><li>Git add .</li><li>Git commit -m “description”</li><li>Git push -u origin “远程分支名称”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 测试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/28/hello-world/"/>
      <url>/2021/07/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>再议爬虫</title>
      <link href="/2020/10/15/2020-10-15-zai-yi-pa-chong/"/>
      <url>/2020/10/15/2020-10-15-zai-yi-pa-chong/</url>
      
        <content type="html"><![CDATA[<p><font color="green" size="3">python的应用场景有很大一部分是基于计算机网络的，因为现在的人们使用计算机来工作不是孤立的，大部分工作都是在网络上完成的，python在处理这方面的事务上是天然的行家里手，这主要是因为它拥有丰富的网络应用接口包，能处理各种各样的网络请求，大大地降低了程序开发的复杂度，提升了应用开发的效率，今天就以爬虫为例，一起来看看常用的python网络工具库的使用场景。</font></p><font color="green" size="3"><p><font color="green" size="2">目前python的网络应用包或工具库主要分为两类: 一类是用于网络请求及文件处理的，另一类是对网页内容进行解析和信息提取的，常用的库有 - urllib，urllib2，urllib3，requests, BeautifulSoup, lxml等，其中urllib，urllib2，urllib3，requests 主要用于前者，而bs和lxml则多用于后者，这里的urllibx区别是针对不同的python版本来说的，而requests的底层实现其实是基于urllib库的。本质上还是urllib的应用拓展，了解了这些，对我们的实际的开发和使用这些类库是很有帮助的。</font></p><font color="green" size="2"></font></font><p><font color="green" size="3"><font color="green" size="2"><font color="green" size="3">废话不多说，一起看例子吧，这是一个简单的网页访问和页面图片内容抓取的应用，基本的实现代码如下 -<br></font></font></font></p><span id="more"></span><pre class="line-numbers language-none"><code class="language-none">基本思路实现 -import requestsfrom bs4 import BeautifulSoupfrom lxml import etreehtmlRequest = requests.get(url) #返回一个requests对象htmlContent = BeautifulSoup(html.text, ''html.parser'') #获得html的本文内容htmlContent.select("img") #获取所有的img tag内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面三步是最直接的网络处理事务流，但要获取准确的信息，光这几行代码是远远不够的，还需要在它的基础上对齐进行包装和完善，增加代码的隐蔽性和执行效率，因为你在网络上爬取人家的信息，一般都不会赤裸裸的去索取，那样的话，人家一定不会让你顺利爬取的，唉, 为什么？这还用问，你懂得。。。<br>下面是我的完整代码，重要处都做了注释说明，相信有点python基础的你，一定会看明白的 ~~</p><pre class="line-numbers language-none"><code class="language-none">访问指定网页，获得页面html内容并返回图片链接的数量 -import requests, urllib, json, os, sys, time, randomfrom bs4 import BeautifulSoup# 每次切换页面就更换headers及ip, 使得每次的访问就像是来自真实的用户访问，这是对requests网路访问的基本封装，你可以先在网页的开发及网络模式下查看，找出request header的基本参数，然后逐一封装，通常用proxy和header就可以了。 proxy_list = [{'HTTP': '175.42.128.96:9999'}, {'HTTP': '119.108.172.244:9000'}, {'HTTP': '122.226.57.70:8888'},  {'HTTP': '125.108.87.88:9000'}, {'HTTP': '122.234.92.111:9000'}, {'HTTP': '121.232.199.95:9000'}, {'HTTP': '175.43.57.17:9999'}, {'HTTP': '163.204.245.61:9999'}, {'HTTP': '123.55.114.251:9999'}, {'HTTP': '110.243.18.179:9999'}, {'HTTP': '125.108.107.118:9000'}, {'HTTP': '125.108.67.101:9000'}, {'HTTP': '123.101.207.19:9999'}, {'HTTP': '113.128.27.16:9999'}, {'HTTP': '125.108.85.59:9000'}, {'HTTP': '125.108.75.165:9000'}, {'HTTP': '123.160.1.227:9999'}, {'HTTP': '125.108.114.61:9000'}, {'HTTP': '171.35.168.185:9999'}, {'HTTP': '120.83.108.100:9999'}, {'HTTP': '123.163.116.39:9999'}, {'HTTP': '106.4.136.158:9000'}, {'HTTP': '120.83.100.162:9999'}, {'HTTP': '175.42.123.75:9999'}, {'HTTP': '113.124.92.168:9999'}, {'HTTP': '112.14.47.6:52024'}, {'HTTP': '125.108.73.169:9000'}, {'HTTP': '222.85.28.130:52590'}, {'HTTP': '123.149.141.196:9999'}, {'HTTP': '123.149.136.233:9999'}, {'HTTP': '123.57.84.116:8118'}, {'HTTP': '125.108.117.67:9000'}, {'HTTP': '175.43.56.16:9999'}, {'HTTP': '175.42.122.25:9999'}, {'HTTP': '175.42.123.160:9999'}, {'HTTP': '125.108.102.60:9000'}, {'HTTP': '125.110.98.55:9000'}, {'HTTP': '175.43.59.57:9999'}, {'HTTP': '123.55.98.218:9999'}, {'HTTP': '171.11.178.35:9999'}] theProxy = random.choice(proxy_list)myHeaders = [     "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",     "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36",     "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0",     "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14",     "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)",     'Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11',     'Opera/9.25 (Windows NT 5.1; U; en)',     'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',     'Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)',     'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12',     'Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9',     "Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7",     "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0 ",     "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 Edg/85.0.564.63" ] header = random.choice(myHeaders) time.sleep(0.1) html = requests.get(url, headers={"User-Agent": header, "Referer": url}, proxies = theProxy) # 获取url，连接连接请求 or write like this  - {'User-Agent': header} {'proxy': theProxy}  &gt;&gt;&gt;&gt;proxies = theProxy print("************* Check header2 -", header) print("************* Print the Preferer - ", url) # if html.raise_for_status() == 200:     # print ("The html source is - \n", html.text) if selectorFlag == "bs":     htmlContent = BeautifulSoup(html.text, 'html.parser') # 此处应该是html.text 而不是html, 这是用beautifulsoup库来提取tag及属性值的解析思路     imgTagQty = len(htmlContent.select("img")) else:     htmlContent = etree.HTML(requests.get(url).text) # 注意此处写法，返回的是Element对象，即htmlCotent是一个Elelment对象，     imgTagQty = len(htmlContent.xpath('//table/tr/td/a/img/@src')) #使用xpath选择器来提取tag和属性值 print("How many pictures are there in this page - ", imgTagQty) return htmlContent, imgTagQty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">抓取图片并保存在指定位置 -def fetchPicture_and_saved(htmlContent, imgTagQty, pathRootPicture, savePictrueFolder, selectorFlag):    for i in range(imgTagQty):    # if "顾欣怡" in soup.select('img')[i]['alt']:        if selectorFlag == "bs":            getImgs = soup.select('img')[i]['src'] # 获取src的值, 所有图片的tag都是img, 属性src则是指向图片的来源            pictureName = getImgs.split("/")[-1] # 获取图片名称            getSuffix = getImgs.split(".")[-1]        else:            getImgList = htmlContent.xpath('//table/tr/td/a/img/@src')            for getImgs in getImgList:                pictureName = getImgs.split("/")[-1]                getSuffix = getImgs.split(".")[-1]        if getSuffix.lower() == "jpg":            if "http://" in getImgs or "https://" in getImgs:                picUrl = getImgs            else:                picUrl = pathRootPicture + getImgs # 拼接图片的完整地址            print(" &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Check the picture URL -\n", picUrl)            pictrueData = requests.get(picUrl).content            if not os.path.exists(savePictrueFolder):                os.makedirs(savePictrueFolder)            savePictureAs = os.path.join(savePictrueFolder, pictureName)            if os.path.exists(savePictureAs):                print("该图片已经存在!")            else:                open(savePictureAs, 'wb').write(pictrueData)                print("保存成功！！！")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">删除缩略图，只保留大尺寸图片 -def deleteSnapShot(savePictrueFolder):    for root, dirs, files in os.walk(savePictrueFolder):        for file in files:            pathpic = root + "\\" + file            picSize = ((os.path.getsize(root + "\\" + file))//1000)            if picSize &lt; 20:                os.remove(pathpic)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">if __name__ == "__main__":    pathRootPicture = r'http://m.qwsgyideyrtys.com'  selectorFlag = ""  savePictrueFolder = r'C:\Users\Luck_Lello\Desktop\PythonDrilling\fetchPictruesFromWebsite\PictureArts_Oct09'  for j in [278, 279, 280]: #167,      for i in range(1, 16):          if i == 1:              url = r'http://m.qwsgyideyrtys.com/dandan/20180713/' + str(j) + '.html'          else:              url = r'http://m.qwsgyideyrtys.com/dandan/20180713/' + str(j) + '_' + str(i) + '.html'          soup, imgTagQty = getResponse_and_imgTag(url, selectorFlag)          fetchPicture_and_saved(soup, imgTagQty,            pathRootPicture, savePictrueFolder, selectorFlag)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码量不是很大，不过是在基本思路实现上增加了访问头header和代理服务的封装，提高了代码的隐蔽性；另外在对页面图片的抓取上采用了beautifulsoap的解析和etree的解析方法，两者都是在将页面内容修正为html代码格式后进行的，主要区别在于etree能直接使用xpath的方法，直接定位到指定的图片，而beautifulsoap虽然也能提取元素的值和属性，但不容易定位到指定的图片，通常是需要遍历来实现的，这增加了时间开销，不可取，但不会放过每一张图片。两种方法都放进来，便于参考学习。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 页面爬虫 </category>
          
          <category> python网络请求及解析库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> urllib </tag>
            
            <tag> urllib2 </tag>
            
            <tag> urllib3 </tag>
            
            <tag> requests </tag>
            
            <tag> BeautifulSoup </tag>
            
            <tag> lxml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium模块的有趣应用场景</title>
      <link href="/2020/10/15/2020-10-15-selenium-mo-kuai-de-you-qu-ying-yong-chang-jing/"/>
      <url>/2020/10/15/2020-10-15-selenium-mo-kuai-de-you-qu-ying-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="Selenium在web游戏中的简单应用"><a href="#Selenium在web游戏中的简单应用" class="headerlink" title="Selenium在web游戏中的简单应用"></a>Selenium在web游戏中的简单应用</h2><ol><li><p>环境准备：</p></li><li><p>1 安装selenium<br>  <em><font color="Red"><code>pip install selenium (#Dos mode)</code></font></em></p></li><li><p>代码实现</p><pre class="line-numbers language-none"><code class="language-none">url = r'https://gabrielecirulli.github.io/2048/'import webbrowser, time, sys, os# webbrowser.open(url)--- 打开2048 website （webbrowser 这里主要用于检验该url是否有效，不用这段代码完全可以）## Selenium automates with Edgefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Webdriver是Selenium的核心，它是python针对不同的Explorer的核心驱动，不同的explorer对应着不同的webdriver版本。</p></li></ol>  <pre class="line-numbers language-none"><code class="language-none"># os.system('taskkill /F /IM Iexplore.exe')os.system('taskkill /fi "imagename eq msedge.exe" /f'), time.sleep(10)driver = webdriver.Edge('C:\python386\msedgedriver.exe') # 需要加上webdriver的路径，如果不加的话，需要将MicrosoftWebDriver.exe放在python的安装文件夹如"C:\Python36\MicrosoftWebDriver.exe" （我的貌似放进去还是会报错 ？？？）driver.maximize_window()time.sleep(3)driver.get(url)print("Check the browser type - ", type(driver))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-none"><code class="language-none">## Selenium automates with Chrome# browser = webdriver.Chrome()# browser.maximize_window()# browser.get(url)# print("Check the browser type - ", type(browser))bodyControl = driver.find_element_by_tag_name('body') # webdriver对键盘的操作实在该对象上进行的n = 1continuePlay = "yes"while continuePlay.upper() == "YES":    if "Game over!" not in driver.find_element_by_xpath("/html/body/div[1]/div[3]/div[1]/p").text:        bodyControl.send_keys(Keys.UP), time.sleep(0.3)        bodyControl.send_keys(Keys.RIGHT), time.sleep(0.3)        bodyControl.send_keys(Keys.DOWN), time.sleep(0.3)        bodyControl.send_keys(Keys.LEFT), time.sleep(0.3)    else:        print("The", n, "cycle of this Game is over!")        continuePlay = input("Do you wanna play again? please enter 'Yes' or 'No' to decide --- ")        if continuePlay.upper() == "YES":            driver.find_element_by_class_name("retry-button").click()            n += 1        else:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 上面代码适用于IE和Chrome，使用了selenium webdriver的常用操作 - 如对象识别方法 xpath，键盘模拟对象Keys，以及基本的判断语法。怎么样？有兴趣的可以copy下来试试看。</p>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
          <category> Python自动化 </category>
          
          <category> WebGui自动化 </category>
          
          <category> Selenium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> selenium </tag>
            
            <tag> webdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论道-论优秀测试管理者的要素</title>
      <link href="/2020/02/14/2020-02-14-lun-dao-lun-you-xiu-guan-li-zhe-de-yao-su/"/>
      <url>/2020/02/14/2020-02-14-lun-dao-lun-you-xiu-guan-li-zhe-de-yao-su/</url>
      
        <content type="html"><![CDATA[<p>最近有不少业内小朋友们问我，做软件测试这个工作难不难？这个行业有潜力吗？能不能长久做下去？加班多不多？收入一般能达到什么段位？。。。哎！不是不想回复，实在是对这些问题提不起兴趣，这么说吧，既然选择这个行业，就不能后悔，一步一个脚印的走下去，终有收获的那一天。如我来说，在软件行业摸爬滚打13年多了，从事测试工作也满10年了，一路上走来，坑坑洼洼，有迷茫，有痛苦，有失落。。。当然更多的还是喜悦。喜欢这个行业，就要义无反顾，就得生死相依。。。<span id="more"></span></p><p>行业本身没有高低贵贱之分，无论你选择做什么行业首先要坚定，不放弃，接下来就是对职业的定位，这个对个人来说有合适与不合适之分，就我熟悉的测试行业来说，你适合于做一个管理者还是某一个专业方向的大咖，这是有很大区别的，千万不选错方向，不然真的是 - 走错路，最后无路可走。</p><h6 id="职业方向选择"><a href="#职业方向选择" class="headerlink" title="职业方向选择 -"></a>职业方向选择 -</h6><p>我认为这个跟个人性格有很大的关系，如果你EQ很高，技术也有一些功底，恭喜你，在我们这个行业，你有成为一名合格管理者的资质，如果你EQ很高，对技术不讨厌，有兴趣学习，恭喜你，选择我们这个行业，你有广阔的发展空间，能成为各个角色的可能（BA，QA，TE，PE，TL，PM etc.），如果你IQ很好，EQ欠佳，没关系，做我们这个行业，你还能成为那个牛气冲天的大咖，可供选择的角色有AT，PT，MT等, 真的很不错:-)。如果真的感觉一般，没啥亮点，那也是可以选择这个行业的，你可以首先成为一个合格的QC，tester，然后再找准兴趣点，往该行业细分支脉冲刺，一定会找到属于自己最终的那个位置。。。</p><p>软件测试是一个系统课题，涵盖的点很多，这里我不想把问题发散，今天就专注在如何做一名合格的测试管理者，有没有切实可行的原则去遵行？答案是肯定的。</p><h6 id="测试管理必备技能"><a href="#测试管理必备技能" class="headerlink" title="测试管理必备技能 -"></a>测试管理必备技能 -</h6><ul><li><input checked="" disabled="" type="checkbox"> <b>了解你的客户</b> - 这个往往容易被忽视，普通测试人员不会去关心客户，了解客户，也没那必要。但作为测试管理者，这个工作你不能忽略，而且要做得越细越好，知道他们的需要和期望，从客户的角度来开展工作，做他们喜欢吃的披萨饼。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>了解业务和核心功能</b> - 这个没得说，做任何工作都得明白你要实现的目标是什么，你要完成的任务点在哪里。。  </li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>平台和业务能力</b> - 熟知当前的平台和团队能力，如此才能制定出更加科学合理的测试计划和实施方案。  </li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>资源管理</b> - 这包括两方面的，一个是测试团队自己的资源能力，另一个是可支配的外部资源能力，这是制定合理测试计划的必要条件。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>测试策略</b> - 根据客户的目标和业务实现的功能，就可以制定测试策略了（把测试需求，测试范围，测试方法，以及测试输入和输出的条件明确的表述出来，我认为就是一个有效的策略了）。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>测试计划</b> - 根据前面掌握的情况，综合团队资源，外部资源，平台，工具，方法，环境等，制定合理，富有弹性的测试计划，确定好每一个输出节点和输出任务。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>测试用例</b> - 监督好测试用例的开发，紧扣需求，侧重核心功能，把关检查点和测试数据，这样的用例更有保留价值。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>测试执行</b> - 这个是测试一个很重要的环节，也是最花时间的一个步骤，一定要事先定义好测试的执行标准（测试启动条件和结束条件），执行周期，以及测试bug的记录，追踪，验证，关闭全过程的监控管理。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>测试管理</b> - 做好测试记录（包括策略，计划，用例，bug），定期收集发现的问题和解决的方案，将有价值的信息整理并形成经验知识库，以利团队整体发展和提高。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>测试回顾</b> - 安排一些有益的团队活动，检验团队的整体战斗力（包括好的经验总结，个人的潜力挖掘，遇到了哪些坑等等）</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>关注团队及个人的发展空间</b> - 不能一味的让团队去卖力的测试，作为管理者，要了解你的团队和团队成员的特征，为他们找好发展的方向，这样的团队才会走得稳，走得远。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>关注部门和公司的发展方向</b> - 了解部门和公司的动态，加强和兄弟团队及部门的沟通协作，及时调整测试策略和人员部署，也是作为管理者经常需要考虑的方面。</li></ul><ul><li><input checked="" disabled="" type="checkbox"> <b>其他</b> - 除了上面提到的技能之外，还有很多，网上也有一些如应变能力，沟通协调能力，陈本控制能力，授权，应急处理等方面，管理本来就不是一尘不变的，它应该是一个不断完善和发展的过程，从粗狂到精细的过程，不可能一蹴而就。了解和熟悉了上面的几个方面，我认为你就具备了成为一名合格测试管理者的硬件标准。您认为呢？</li></ul><h6 id="晋级管理"><a href="#晋级管理" class="headerlink" title="晋级管理 -"></a>晋级管理 -</h6><p>管理是一门艺术，艺术是没有止境的，想要在管理上有一番作为，唯有脚踏实地，积极参与，从试错中总结经验，不断的批判和完善自我，才有可能站得更高，望得更远，下面是我的一点小建议：<br></p><ul><li><input disabled="" type="checkbox"> 多读书，读有关联度的书</li><li><input disabled="" type="checkbox"> 了解行业动向，和技术发展方向，多读一些技术原理的书</li><li><input disabled="" type="checkbox"> 充分挖掘自身优势，建立优势城池</li><li><input disabled="" type="checkbox"> 要有短期计划和长期规划</li><li><input disabled="" type="checkbox"> 对不相干的问题，尽量不去耗费精力</li><li><input disabled="" type="checkbox"> 锻炼说话能力，优秀的管理者都是屁精话痨 ^_&lt; 个人观点 :-)</li><li><input disabled="" type="checkbox"> 培养处事不惊的应变能力，平时多一些练习，用时hold得住。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 测试管理 </category>
          
          <category> 测试管理的要素 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to deal with email from Outlook by Python</title>
      <link href="/2019/12/10/2019-12-10-how-to-deal-with-email-from-outlook-by-python/"/>
      <url>/2019/12/10/2019-12-10-how-to-deal-with-email-from-outlook-by-python/</url>
      
        <content type="html"><![CDATA[<p>前面有篇文章介绍过如何使用Python的smtplib文件来操作POP3协议，以实现邮件收发的自动化操作，使用smtplib文件来收发邮件，需要事申请邮箱的授权码，并且在工作邮箱账户设置好授权码之后，脚本才能实现其功能。其实没有那么麻烦，这里在再介绍另外一种方法，可以更方便地实现邮件的自动化收发。</p><p>今天要介绍的就是Python的win32com接口文件，该文件几乎包含了所有的Windows API接口，是python编程必须掌握的核心模块，下面重点说说如何使用Win32模块实现Outlook的邮件收发功能。</p><ol><li>获取Win32模块 -</li></ol><ul><li>通常通过python管道来安装 - pip install pywin32</li><li>有时pip管道安装并不顺利，windows用户可以试着直接下载安装文件来直接安装：</li><li><a href="https://sourceforge.net/projects/pywin32/files/pywin32">pywin32 module</a></li></ul><ol start="2"><li>自定义类及收发邮件方法实现 -</li><li>详细设计 -</li><li>代码实现 -</li></ol><span id="more"></span><pre class="line-numbers language-none"><code class="language-none">import win32com.client as win32class outlook():  '''  Operation local Outlook application  '''  def init(self):    pass  def openoutlook(self):    pass  def sendmail(self, receivers, title, body, attach_path=None):    """    Send the mail -    ：param receivers：receivers    ：param title：mail title    ：param body：mail body    ：param attach_path：attached file    ；retun: send    """    outlook = win32.Dispatch('Outlook.Application')    mail = outlook.CreateItem(0) # don't miss the initial parameter here    # If multiple receivers, doing like this -    if isinstance(receivers, list):        if len(receivers) &gt; 1:            mail.To = ';'.join(receivers)        else:            mail.To = receivers[0]    else:        mail.To = receivers    mail.Subject = title    mail.Body = body    if attach_path is None:        pass    else:        mail.Attachments.Add(attach_path)    mail.Send()  def draftmail(self, receivers, title, body, attach_path=None):    """    Save the mail draft    :param receivera:recievers    :param title: title    :param body: mail body    :param attach_path: attached file    :return:save    """    outlook = win32.Dispatch('Outlook.Application')    mail = outlook.CreateItem(0)    # If multiple receivers, doing like this -    if isinstance(receivers, list):        if len(receivers) &gt; 1:            mail.To = ';'.join(receivers)        else:            mail.To = receivers[0]    else:        mail.To = receivers    mail.Subject = title    mail.Body = body    if attach_path is not None:        mail.Attachments.Add(attach_path)    mail.Save()  def readNewMail(self):    outlook = win32.Dispatch('Outlook.Application').GetNamespace("MAPI")    inbox = outlook.GetDefaultFolder(6) # 6 means the inbox folder refer to https://docs.microsoft.com/en-us/office/vba/api/outlook.oldefaultfolders    body_content = inbox.Items.GetLast().body    return body_contentif __name__ == '__main__':    otlk = outlook()    last_new_mail = otlk.readNewMail()    print(last_new_mail)    title = "Testing for mail sending automatically"    receivers = "alan_yuan009@live.cn"    body = 'This is a test mail which sended by Python script automatically, doing this, we hope we would use this to send our test bug regularlly, so dont reply it, it is test purpose only. Thanks. Alan!'    filep = r"C:/RTKlog.log"    otlk.sendmail(title=title, receivers=receivers, body=body, attach_path=filep)        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1. 另外，在安装pywin32模块时，要选择和python版本一致的安装包，下面几个常用python命令，可以查看Python的版本和详细安装信息-</strong>*</p><p><strong>DOS Mode -</strong></p><blockquote><ul><li>python</li></ul><ul><li>import sys</li></ul><ul><li>sys.version</li></ul><ul><li>sys.version_info</li></ul><ul><li>sys.winver</li></ul></blockquote><p><strong>2. pip管理第三方包常用命令</strong></p><blockquote><p>  pip install python_moudule<br>  pip list<br>  pip install –upgrade somePackage<br>  pip uninstall somePackage<br>  freeze list<br>  python setup.py install (for the packages which unzip with setup.py file)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
          <category> Python自动化 </category>
          
          <category> Outlook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> Python自动化 </tag>
            
            <tag> outlook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试之我见</title>
      <link href="/2019/10/10/2019-10-10-app-ce-shi-zhi-wo-jian/"/>
      <url>/2019/10/10/2019-10-10-app-ce-shi-zhi-wo-jian/</url>
      
        <content type="html"><![CDATA[<p>经历过几个App项目之后，结合之前做过的web项目，总觉得有些东西需要理一理，从测试的角度来看，Web端与App测试有哪些不一样？测试人员需要从哪些方面进行验证？应该怎样去设计和开展测试工作？这里是我的一点点心得：</p><h5 id="1-系统结构方面"><a href="#1-系统结构方面" class="headerlink" title="1 系统结构方面 -"></a>1 系统结构方面 -</h5><p>Web项目 - 主要是基于B/S架构来部署的，用户需要从浏览器来进行操作，在Web的测试过程中，客户端会随服务器端同步更新，测试的重点主要放在服务器端。<br>App项目 - 是基于C/S架构的，客户端多半是移动手持设备，在App测试过程中，只要修改了服务端，那么客户端用户所有核心版本都需要进行回归测试。</p><h6 id="2-系统性能方面"><a href="#2-系统性能方面" class="headerlink" title="2 系统性能方面"></a>2 系统性能方面</h6><p>Web项目 - 通常需要监控系统的响应时间、CPU Utility、Memory Utility，Temperature, Through out/put rate, Concurrent thread/user etc. 通过这些参数找出系统的临界点，并给于相应的建议。<br>App项目 - 通常将重点放在测响应时间、流量、电量、场景等方面</p><h5 id="3-系统兼容方面"><a href="#3-系统兼容方面" class="headerlink" title="3 系统兼容方面"></a>3 系统兼容方面</h5><p>Web项目 - 通常从操作系统和浏览器等方面来考量，如是否兼容系统（Windows7、Windows10、Linux等）是否兼容浏览器 IE6、IE8、Firefox、Chrome等）<br>App项目 - 则侧重于不同的设备和系统，如Andriod系统是否兼容各主流厂商设备，IOS系统是否兼容各apple主流设备如iPhone，iPAD，iWatch等</p><span id="more"></span><h5 id="4-测试工具方面"><a href="#4-测试工具方面" class="headerlink" title="4 测试工具方面"></a>4 测试工具方面</h5><p>Web测试 - 自动化工具通常使用Selenium，QTP, RFT, WinRunner 等等，性能测试工具通常使用LoadRunner / JMeter （参看下面的截图）<br>App测试 - 自动化工具通常使用Appium / AutomatorUI / SeeTest 等 ，性能测试工具通常使用JMeter</p><h5 id="5-特征测试方面"><a href="#5-特征测试方面" class="headerlink" title="5 特征测试方面"></a>5 特征测试方面</h5><p>Web特征测试主要包括：<br>链接测试 - 主要是保证链接的可用性和正确性，考虑链接的页面是否存在？是否按指示链接到了相应链接的页面？是否存在空白页面等<br>图形测试 - 确保图形有明确用途，图片或动画不要过于紧凑，以免浪费传输时间；其次，验证文字回绕是否正确<br>打印机测试 - 考虑网页打印是否正常（显示的图片和文本的对齐方式可能与打印出来的东西不一样，是否完整打印）</p><h4 id="App特征测试主要包括："><a href="#App特征测试主要包括：" class="headerlink" title="App特征测试主要包括："></a>App特征测试主要包括：</h4><p><em><strong>1. 安装、更新、卸载</strong></em><br>安装：需考虑安装时的中断、弱网以及安装后删除安装文件等情况<br>更新：分强制更新、非强制更新、增量包更新、断点续传、弱网状态下更新等几种情况<br>卸载：需考虑卸载后App相关文件是否删除干净<br><em><strong>2. 权限测试</strong></em><br>设置某个App是否可以获取该权限，比如是否可访问短信、读取联系人、相册、照相机、位置信息等<br>安全测试<br>安装包是否可反编译代码、安装包是否签名、权限设置<br><em><strong>3. 边界测试</strong></em><br>可用存储空间少、飞行模式、系统时间有误、第三方登录（QQ、微信、微博登录）以及没有SD卡/双SD卡等<br>界面操作<br>关于手机端测试，需注意横竖屏切换、多点触控、手势、事件触发区、前后台的切换（从后台回到App，检查是否停留在上次操作界面、功能和应用状态是否一样）等<br><em><strong>4. 干扰测试</strong></em><br>电话响应（接通、呼叫挂断、呼叫保持）、收发短信、中断（插拔数据线、手机锁屏、闹钟、蓝牙等）、电量不足、关机、重启、死机等<br><em><strong>5. 网络测试</strong></em><br>首先，弱网络测试（模拟2G、3G、4G、WiFi网络状态以及丢包情况，重点要考虑回退和刷新是否会造成二次提交）；其次，网络切换测试（网络断开后重连、3G切换到4G/WiFi等）<br><em><strong>6. 中断测试</strong></em><br>在使用App的过程中，网络中断或者设备故障的场景也是时有发生的，这类测试在交易类的App中尤为重要，模拟中断或故障场景，看交易是否停留在上次操作界面<br><em><strong>7. 多点登陆测试</strong></em><br>同时登录多台设备，看App是否能记录登录节点，并确保只有一台设备工作正常<br><em><strong>8. 其他</strong></em><br>用户验证，密码找回，权限设置等也是App类测试常常要考虑的覆盖面。<br><em><strong>9. 闭环测试</strong></em><br>主要用于业务场景的流程验证，用来检验业务的逻辑性和可靠性。这在报表统计，业务数据展示，确保前后台数据一致性方面尤为重要。</p><h5 id="附图"><a href="#附图" class="headerlink" title="附图 -"></a>附图 -</h5><blockquote><p><img src="/medias/automationTools.JPG" alt="常用自动化测试工具"></p></blockquote><p>————————————————<br>未完待续 。。。</p>]]></content>
      
      
      <categories>
          
          <category> App Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App Testing </tag>
            
            <tag> Andriod </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发模式之Agile实践总结</title>
      <link href="/2019/01/09/2019-01-09-zai-pin-ruan-jian-kai-fa-mo-shi-zhi-agile/"/>
      <url>/2019/01/09/2019-01-09-zai-pin-ruan-jian-kai-fa-mo-shi-zhi-agile/</url>
      
        <content type="html"><![CDATA[<p><font size="4" color="red" face="华文彩云">Scrum是Agile模式的一个实施框架，可以理解为Agile理念的框架实现单元。</font></p><h4 id="1-Scrum中的角色有"><a href="#1-Scrum中的角色有" class="headerlink" title="1. Scrum中的角色有 -"></a>1. Scrum中的角色有 -</h4><p>*** Scrum Master ***<br>保护团队不受外界干扰，是团队的领导和推进者，负责提升 Scrum 团队的工作效率，控制 Scrum 中的“检视和适应”周期过程。与 Product Owner 一起将投资产出最大化，他确保所有的利益相关者都可以理解敏捷和尊重敏捷的理念。</p><p>*** Team Players(Devolper, QA, DB, Art etc.) ***<br>团队负责交付产品并对其质量负责，团队与所有提出产品需求的人一起工作，包括客户和最终用户，并共同创建 Product Backlog 。团队按照大家的共识来创建功能设计、测试 Backlog 条目交付产品。</p><p>*** Product Owner ***<br>从业务角度驱动项目，传播产品的明确愿景，并定义其主要特性。Product Owner 的主要职责是确保团队只开发对于组织最重要的 Backlog 条目，在 Sprint 中帮助团队完成自己的工作，不干扰团队成员，并迅速提供团队需要的所有信息。</p><p>*** Manager(PM,Investor) ***<br>管理层要为 Scrum 团队搭建良好的环境，以确保团队能够出色工作，必要的时候，他们也会与 Scrum Master 一起重新组织结构和指导原则。</p><p>*** Customer ***<br>客户是为 Scrum 团队提出产品需求的人，她会与组织签订合同，以开发产品。一般来说，这些人是组织中的高级管理人员，负责从外部软件开发公司购买软件开发能力。在为内部产品的公司中，负责批准项目预算的人就是客户。</p><h4 id="2-Scrum-中的产出物"><a href="#2-Scrum-中的产出物" class="headerlink" title="2. Scrum 中的产出物"></a>2. Scrum 中的产出物</h4><p>** Product Backlog——Backlog 待开发项，积压的任务。**<br>产品 Backlog 包括了所有需要交付的内容，其内容根据业务需求的价值顺序排列，每个 Backlog 的优先级是可以调整的，需求是可以增减的，因此产品 Backlog 将根据不断增长来持续驱动维护。 Product backlog 中列举了本项目应该实现的需求，需求采用了用户故事的方式进行描述，</p><p>** Sprint Backlog - Sprint 本意为“冲刺”，指迭代周期(1~5 weeks)**<br>在 Sprint 开始前，定义本次 Sprint 要讨论的“Sprint Backlog”，从中产生本次 Sprint 要完成的 “已定 Product Backlog”。</p><p>** Product Backlog **<br>Sprint 计划会议的产物，它定义了团队所接受的工作量，在整个 Sprint 过程中它将保持不变。</p><p>** User Story、Task - 用户故事、任务 **<br>用 User Story 来描述 Sprint Backlog 里的项目，<font color="red">User Story 是从用户的角度对系统的某个功能模块所作的简短描述。一个 User Story 描述了项目中的一个小功能，以及这个功能完成之后将会产生什么效果，或者说能为客户创造什么价值。</font> 一个 User Story 的大小和复杂度应该以能在一个 Sprint 中完成为宜。如果 User Story 太大，可能会导致对它的开发横跨几个 Sprint，此时就应该将这个 User Story 分解。<font color="red">为了能够及时，高效地完成每个 Story，Scrum 团队会把每个 Story 分解成若干个 Task。每个Task 的时间最好不要超过8小时，保证在1个工作日内完成，如果 Task 的时间超过了8个小时，就说明Task的划分有问题，需要特别注意。</font></p><p>** 障碍 Backlog - 问题列表，积压的待处理事务。**<br>列举了所有团队内部和团队相关的和阻碍项目的进度的问题，Scrum Master 需要确保所有的障碍 Backlog 中的问题都已分配并可以得到解决。</p><span id="more"></span><h4 id="3-Sprint-会议通用规则"><a href="#3-Sprint-会议通用规则" class="headerlink" title="3. Sprint 会议通用规则"></a>3. Sprint 会议通用规则</h4><p>** 基本要求 **<br>•    每次会议都要准时开始、准时结束。<br>•    每次会议都采取开放形式，所有人都可以参加。</p><p>** 会前准备 **<br>•    提前邀请所有必须参会的人，让他们有时间准备。<br>•    发送带有会议目标和意图的会议纲要。<br>•    预订会议所需的全部资源：房间、投影仪、挂图、主持设备，以及此会议需要的其他东西。<br>•    会前24小时发送提醒。<br>•    准备带有会议规则的挂图。</p><p>** 会议推进 **<br>•    展开讨论时，会议的推进人必须在场。他不能参与到具体讨论中，但是他需要注意讨论进程，如果讨论参与者失去重点，他还要将讨论带回正规。<br>•    推进人展示会议的目标和意图。<br>•    有必要时，推进人可以商定由某个撰写会议记录。<br>•    推进人可以记录团队的意见，或是教授团队如何自己记录文档；而且推进人可能会在挂图上进行记录，将对话可视化。<br>•    推进人会对会议进行收尾，并进行非常简短的回顾。</p><p>** 会议输出 **<br>•    使用手写或挂图说明来记录文档，给白板和挂图上的内容拍照。<br>•    必须传达会议记录和大家对会议结果的明确共同认知。</p><p>** 让团队坐在一起！**<br>•    大家都懒的动，尽量让“产品负责人”和“全功能团队”都坐在一起！<br>•    互相听到：所有人都可以彼此交谈，不必大声喊，不必离开座位。<br>•    互相看到：所有人都可以看到彼此，都能看到任务板——不用非得近到可以看清楚内容，但至少可以看到个大概。<br>•    隔离：如果你们整个团队突然站起来，自发形成一个激烈的设计讨论，团队外的任何人都不会被打扰到，反之亦然。</p><p>** 团队建设 **<br>•    Scrum 团队最佳人数控制在“5～9”人。<br>•    全职能性团队：开发组（后台开发、前端开发、测试人员——3~8人）、Scrum Master（项目经理）、产品负责人<br>•    兼职团队成员：美工、DBA、运维</p><h4 id="4-每日立会（Daily-Standup-Meeting-建议下班前开始"><a href="#4-每日立会（Daily-Standup-Meeting-建议下班前开始" class="headerlink" title="4. 每日立会（Daily Standup Meeting) - 建议下班前开始"></a>4. 每日立会（Daily Standup Meeting) - 建议下班前开始</h4><p>** 会议目的 **<br>•    团队在会议中作计划，协调其每日活动，还可以报告和讨论遇到的障碍。<br>•    任务板能够帮助团队聚焦于每日活动之上，要在这个时候更新任务板和燃尽图。</p><p>** 构成部分 **<br>•    任务板、即时贴、马克笔<br>•    提示：ScrumMaster 不要站在团队前面或是任务板旁边，不要营造类似于师生教学的气氛。</p><p>** 基本要求 **<br>•    成员：团队、Scrum Master<br>•    无法出席的团队成员要由同伴代表。<br>•    持续时间/举办地点：每天15分钟，同样时间，同样地点。<br>•    提示：团队成员在聆听他人发言时，都应该想这个问题：“我该怎么帮他做得更快？”</p><p>** 会议输出 **<br>•    团队彼此明确知道各自的工作，最新的工作进度图。<br>•    得到最新的“障碍 Backlog”<br>•    得到最新的“Sprint Backlog”</p><p>** 会议过程 **<br>•    团队聚在故事板旁边，可以围成环形。<br>•    从左边第一个开始，向团队伙伴说明他到现在完成的工作。<br>•    然后该成员将任务板上的任务放到正确的列中。<br>•    如果可以的话，该成员可以选取新的任务，交将其放入“进行中工作”列。<br>•    如果该成员遇到问题或障碍，就要将其报告给 Scrum Master。<br>•    每个团队成员重复步骤2到步骤5。</p><p>** 每个人三个问题：**<br>•    上次会议时的任务哪些已经完成？：把任务从“正在处理”状态转为“已完成”状态。——今天完成了什么？<br>•    下次会议之前，你计划完成什么任务？：如果任务状态为“待处理”，转为“正在处理”状态。如果任务不在 Sprint Backlog 上，则添加这个任务。如果任务不能在一天成，把这任务细分成多个任务。如果任务可以在一天内完成，把任务状态设为“正在处理”。如果任务状态已经是“正在 处理”，询问是否存在阻碍任务完成得问题。——明天做什么？<br>•    有什么问题阻碍了你的开发？：如果有阻碍你的开发进度的问题，把该障碍加入到障碍 Backlog中。——今天遇到了什么问题？</p><p>** 注意事项 **<br>•    不要迟到<br>•    不要超出限制时间<br>•    不要讨论技术问题<br>•    不要转变会议话题<br>•    不要在没有准备的情况下参加<br>•    Scrum Master 不要替团队成员移动任务卡片，不要替团队更新燃尽图。<br>•    Scrum Master 不要提出问题，团队成员不要向 Scrum Master 或管理层人员报告。<br>•    如果不能出席会议，需要通知团队，并找一名代表参加。</p><h4 id="5-任务板"><a href="#5-任务板" class="headerlink" title="5. 任务板"></a>5. 任务板</h4><p>•    任务板集合了选择好的 Product Backlog 和 Sprint Backlog，并以可视化方式展示。<br>•    任务板只能由团队维护，使用不同颜色的“即时贴”来区分开发人员，或者在“即时贴”写上接受任务的姓名。<br>•    尽量使用大白板，也可以使用软件。<br>** 任务板有4列：**<br>•    选择好的 Product Backlog：按照优先级，将团队在当前 Sprint 中要着手的 Product Backlog 条目或是故事放在该列中。<br>•    待完成的任务：要完成一个故事，你得完成一些任务。在 Sprint 规划会议中，或是在进行当前 Sprint 中，收集所有特定 Backlog 条目需要完成的新任务，并将它们放入该列。<br>•    进行中的工作：当团队成员开始某个任务后，他会将该任务对应的卡片放到“进行中的工作”列中。从上个每日 Scrum 例会开始，没有完成的任务都会放在该列中，并在上面做标记（通常是个红点）。如果某个任务在“待完成任务”列中所处时间超过一天，就尽量将该任务分为更小 的部分，然后把新任务放到那一列，移除其所属大任务卡片。如果一个新任务因为某个障碍无法完成，就会得到一个红点标记，Scrum Master 就会记下一个障碍。<br>•    完成：当一个任务卡完成后，完成此任务的成员将其放入“完成”列，并开始选取下一张任务卡。</p><h4 id="6-燃尽图（Burn-Down-Chart）"><a href="#6-燃尽图（Burn-Down-Chart）" class="headerlink" title="6. 燃尽图（Burn Down Chart）"></a>6. 燃尽图（Burn Down Chart）</h4><p>•    跟踪进度要由团队来完成，燃尽图的横轴表示整个Sprint 的总时间，纵轴表示 Sprint 中所有的任务，其单位可以是小时，人天等。一般来说，燃尽图有”Sprint燃尽图”和”Release燃尽图”之分。<br>•    团队每天更新燃尽图。<br>•    如果燃尽图一直是上升状态，或当 Sprint 进行一段时间之后，Sprint 燃尽图上的Y值仍然与 Sprint 刚开始时相差无几，就说明这个 Sprint 中的 Story 过多，要拿掉一些 Story 以保证这个 Sprint 能顺利完成。 如果Sprint 燃尽图下降得很快，例如 Sprint 刚过半时Y值已经接近0了，则说明这个 Sprint 分配的任务太少，还要多加一些任务进来。在 Sprint 计划会议上，如果团队对即将要做的任务理解和认识不充分，就很可能导致这两种情况的出现。（锻炼团队人员的自我估算时间）<br>•    燃尽图要便于团队更新，没必要让它看起来很炫，也不要过于复杂，难以维护。<br>Release 燃尽图：记录整个Scurm项目的进度，它的横轴表示这个项目的所有Sprint， 纵轴表示各个Sprint开始前，尚未完成的工作，它的单位可以是个（Story 的数量），人天等。</p><p>** Sprint 规划会议 - 第一部分**<br>会议目的</p><ul><li>该会议的工作以分析为主，目的是要详细理解最终用户到底要什么，产品开发团队可以从该会议中详细了解最终用户的真实需要。在会议的结束，团队将会决定他们能够交付哪些东西。</li><li>产品负责人在会前准备：条目化的需求（用户故事），优先级排序，最近1~2个迭代最希望看到的功能。会前准备至关重要，可帮助产品负责人理清头绪，不至于在迭代期内频繁提出变更、增加或删除故事。<br>基本要求</li><li>迭代计划会在每个迭代第一天召开，目的是选择和估算本次迭代的工作项。</li><li>只有团队成员才能决定团队在当前 Sprint 中能够领取多少个 Backlog 条目的工作。</li></ul><p>构成部分：</p><ul><li>经过估算和排序的 Product Backlog。</li><li>挂图、马克笔、剪刀、胶水、即时贴、白板、铅笔和蜡笔。</li><li>假期计划表、重要人员的详细联系信息。</li><li>参会成员：团队成员、Scrum Master、产品负责人</li><li>持续时间：在 Sprint 中，每周该会议占用时间为 60 分钟，在早上召开该会议，这样还有可能在同一天召开 Sprint 规划会议的第二部分。</li></ul><p>会议输出<br>•    选择好的 Product Backlog 条目。<br>•    各个 Backlog 条目的需求。<br>•    各个 Backlog 条目的用户验收测试。</p><p>会议过程<br>•    从第一个 Product Backlog 条目（故事）开始。<br>•    讨论该 Product Backlog 条目，以深入理解。<br>•    分析、明确用户验收测试。<br>•    找到非功能性需求（性能、稳定性…）<br>•    找到验收条件。<br>•    弄清楚需要“完成”到何种水平。<br>•    获得 Backlog 条目各个方面的清晰了解。<br>•    绘制出所需交付物的相关图表，包括流程图、UML图、手绘草图、屏幕 UI 设计等。<br>•    回到步骤1，选取下一个 Backlog 条目。</p><p>流程检查：询问团队能否快速回答下列问题，只需要简要回答即可：“我们能在这个 Sprint 中完成第一个 Backlog 条目吗？”如果能得到肯定的回答，那么继续询问下一个 Backlog 条目，一直到已经分析完的最后一个 Backlog 条目。——接下来，休息一下。在休息后，对下一个 Backlog 条目展开上述流程。</p><p>结束流程：<br>•    在 Sprint 规划会议第一部分结束前留出 20 分钟。<br>•    再次提问——这次要更加严肃、正式：“你们能否完成第一个 Backlog 条目，…第二个，…？”<br>•    如果团队认为他们不能再接受更多的 Backlog 条目，那就停下来。<br>•    现在是非常重要的一步：送走 Product Owner，除了团队和 Scrum Master 之外的所有人，都得离开。<br>•    当其他人都离开后，再询问团队：“说真的——你们相信自己可以完成这个列表？”<br>•    希望团队现在能短暂讨论一下，看看他们到底认为自己能完成多少工作。<br>•    将结果与 Product Owner 和最终用户沟通。<br>注意事项：不要改变 Backlog 条目大小，不要估算任务。</p><p>Sprint 规划会议——第二部分（下午）<br>会议目的<br>•    该会议的工作以设计为主，产品开发团队可以为他们要实现的解决方案完成设计工作，在会议结束后，团队知道如何构建他们在当前 Sprint 中要开发的功能。<br>基本要求<br>•    只有产品开发团队才能制定解决方案，架构师或其他团队之外的人只是受邀帮助团队。<br>构成部分：<br>•    能够帮助团队在该 Sprint 中构建解决方案的人，比如厂商或是来自其他团队的人员。<br>•    选择好的 Product Backlog 条目。<br>•    挂图……<br>注意事项：不要估算任务，不要分配任务。</p><p>会议输出<br>•    应用设计、架构设计图、相关图表<br>•    确保团队知道应该如何完成任务！</p><p>会议过程<br>•    从第一个 Backlog 条目开始。<br>•    查看挂图，确定对于客户的需求理解正确。<br>•    围绕该 Backlog 条目进行设计，并基于下列类似问题：<br>o    我们需要编写什么样的接口？<br>o    我们需要创建什么样的架构？<br>o    我们需要更新哪些表？<br>o    我们需要更新或是编写哪些组件？<br>o    ……<br>当团队明确知道自己应该如何开发该功能后，就可以转向下一个 Backlog 条目了。在会议的最后 10 分钟，团队成员使用即时贴写出初步的任务。这能帮助团队成员知道接下来的工作从哪里开展，将这些任务放在任务板上。</p><p>持续时间：在 Sprint 规划会议第一部分完成后，召开该会议。可以将午餐作为两次会议的一个更长久的休息。但是要在同一天完成 Sprint 规划第一部分，在 Sprint 中，每周该会议占用时间为 60 分钟。</p><h4 id="7-Sprint-估算会议"><a href="#7-Sprint-估算会议" class="headerlink" title="7. Sprint 估算会议"></a>7. Sprint 估算会议</h4><p>会议目的<br>•    要做好战略规划，你需要知道 Backlog 中各项的大小，这是版本规划的必要输入；如果想知道团队在一个 Sprint 中能够完成多少工作，这个数据也是必须的。<br>•    团队成员可以从会议中知道项目接下来的阶段会发生哪些事情。<br>基本要求<br>•    只有团队才能作估算，Product Owner（产品负责人）需要在场，以帮助判定某些用户故事能否拆分为更小的故事。<br>构成部分：<br>•    Product Owner 根据业务价值排定 Product Backlog 各项顺序。<br>•    需要参加的人员：Team、Product Owner、User、Scrum Master<br>注意事项：<br>•    不要估算工作量大小——只有团队能这么做。<br>•    Product Owner 不参与估算。<br>会议过程<br>•    Prodcut Owner 展示她希望得到估算的 Product Backlog 条目。<br>•    团队使用规划扑克来估算 Backlog 条目。<br>•    如果某个 Backlog 条目过大，需要放到下一个或是后续的 Sprint 中，团队就会将该大 Backlog 条目划分为较小的几个 Backlog 条目，并对新的 Backlog 条目使用规划扑克进行估算。<br>•    重新估算 Backlog 中当前没有完成、但是可能会在接下来三个 Sprint 中要完成的条目。<br>持续时间：该会议时间限制为不超过90分钟。如果 Sprint 持续时间长于一周，那么每个 Sprint 举行两次估算会议比较合适。<br>会议输出<br>•    经过估算的 Product Backlog。<br>•    更小的 Backlog 条目。</p><h4 id="8-扑克牌估算（Planning-Poker）"><a href="#8-扑克牌估算（Planning-Poker）" class="headerlink" title="8. 扑克牌估算（Planning Poker）"></a>8. 扑克牌估算（Planning Poker）</h4><p>** 具体步骤：**</p><ol><li>每个人各自估算后独立出暗牌，听口令一起开牌。</li><li>数值最大者与最小者PK，其他人旁听也可参考。</li><li>讨论结束后重新出牌和开牌。</li><li>重复上述过程，直到结果比较接近。</li></ol><p><em><strong>常见问题</strong></em></p><ul><li>1、为什么任务要分给组而不是个人？<br>答：因为怕出错了牌又说不出所以然，这样即使日后他不做这个功能，也对这个功能很了解。</li><li>2、为什么不让最后领任务的人自己估算？<br>答：因为他很可能因为不知道某代码可用、不知道某软件不行….而选择了错误的实现方法。</li><li>3、为什么不让师傅估算大家采纳，他不是最厉害吗？<br>答：师傅的想法常常是徒弟们理解不了的，比如为什么不留在女儿国而偏偏去西天取经之类的，共同估算就是让大家在思考中对照自己的实现方法和师傅差异的过程。</li></ul><h4 id="9-Sprint-评审会议（Review-Meeting）根据项目需要举行"><a href="#9-Sprint-评审会议（Review-Meeting）根据项目需要举行" class="headerlink" title="9. Sprint 评审会议（Review Meeting）根据项目需要举行"></a>9. Sprint 评审会议（Review Meeting）根据项目需要举行</h4><p>会议目的</p><ul><li>Scrum 团队在会议中向最终用户展示工作成果，团队成员希望得到反馈，并以之创建或变更 Backlog 条目。</li></ul><p>基本要求</p><ul><li>Sprint 复审会议允许所有的参与者尝试由团队展示的新功能。</li></ul><p>构成部分</p><ol><li>•    有可能发布的产品增量，由团队展示。<br>会议输出</li><li>•    来自最终用户的反馈。</li><li>•    障碍 Backlog 的输入。</li><li>•    团队 Backlog 的输入。</li><li>•    来自团队的反馈为 Product Backlog 产生输入。<br>持续时间：90分钟，在 Sprint 结束时进行。</li></ol><p>会议过程</p><ol><li>•    Product Owner 欢迎大家来参加 Sprint 复审会议。</li><li>•    Product Owner 提醒大家关于本次 Sprint 的目的：Sprint 目标、Scrum 团队在本次 Sprint 中选定要开发的故事。</li><li>•    产品开发团队展示新功能，并让最终用户尝试新功能。</li><li>•    Scrum Master 推进会议进程。</li><li>•    最终用户的反馈将会由 Product Owner 和/或 Scrum Master 记录在案。</li></ol><p>注意事项：</p><ul><li>•    不要展示不可能发布的产品增量。</li><li>•    Scrum Master 不要负责展示结果。</li><li>•    团队不要针对 Product Owner 展示。</li></ul><p>Sprint 反思会议（Retrospective Meeting）- 根据项目需要举行<br>会议目的<br>•    该会议的对应隐喻：医疗诊断！其目的不是为了找到治愈方案，而是要发现哪些方面需要改进。</p><p>构成部分<br>•    参与人员：团队成员、Scrum Master</p><p>基本要求<br>•    从过去中学习，指导将来。<br>•    改进团队的生产力。</p><p>注意事项<br>•    不要让管理层人员参与会议。<br>•    不要在团队之外讨论找到的东西。</p><p>会议输出<br>•    障碍 Backlog 的输入。<br>•    团队 Backlog 的输入。</p><p>持续时间：90分钟，在 Sprint 评审会议结束后几分钟开始。<br>会议过程<br>•    准备一个写着“过去哪些做的不错？”的挂图。<br>•    准备一个写着“哪些应该改进？”的挂图。<br>•    绘制一条带有开始和结束日期的时间线。<br>•    给每个团队成员发放一叠即时贴。<br>•    开始回顾。<br>•    做一个安全练习。<br>•    收集事实：发放即时贴，用之构成一条时间线。每个团队成员（包括 Scrum Master）在每张即时贴上写上一个重要的事件。<br>•    “过去哪些做的不错？”：采取收集事实同样的过程，不过这次要把即时贴放在准备好的挂图上。<br>•    做一个分隔，以区分“过去哪些做的不错”和接下来要产出的东西。<br>•    “哪些应该改进？”：像“过去哪些做的不错”那样进行。<br>•    现在将即时贴分组：<br>•    我们能做什么? 团队 Backlog 的输入。<br>•    哪些不在我们掌控之内？障碍 Backlog 的输入。<br>•    根据团队成员的意见对两个列表排序。<br>•    将这两个列表作为下个 Sprint 的 Sprint 规划会议第一部分和 Sprint 规划会议第二部分的输入，并决定到时候要如何处理这些发现的信息。</p><p><font color="red">Product backlog</font> = 需求 + 优先级<br>           = <font color="green">用户故事 + 优先级 + 验收标准</font><br>           = <font color="blue">用户角色 + 功能 + 目的 + 优先级 + 验收标准</font></p><p><a href="https://blog.csdn.net/bamboolsu/article/details/43951999">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试管理 </category>
          
          <category> Agile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Scrum </tag>
            
            <tag> Sprint </tag>
            
            <tag> Standup </tag>
            
            <tag> Catalog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The first lesson of New Year - PPT</title>
      <link href="/2018/12/13/2018-12-13-the-first-lesson-of-new-year-ppt/"/>
      <url>/2018/12/13/2018-12-13-the-first-lesson-of-new-year-ppt/</url>
      
        <content type="html"><![CDATA[<p>又到了年终总结的时候了，回顾过去展望未来是职场中的您每年的必修课，此时的PPT绝对是主角儿，那种赏心悦目的PPT不仅能吸引与会者的关注，还能给自己带来意想不到的收获，好处是不言而喻的。在网上搜了一些PPT，绝大部分都是收费的，要想找到一份称心如意的模板还真不是那么容易，这里有部分干货，现分享出来，喜欢的请拿走 -</p><!--*<font size=8 color='blue'>模板示例</font>*--><p><marquee onmouseout="this.start()" onmouseover="this.stop()"><span style="font-weight: bolder;font-size: 28px; color:red">All of these are free to you！</span></marquee></p><p><img src="/medias/ppt1.png" alt="截图1"><br><img src="/medias/ppt2.jpg" alt="截图2"><br><img src="/medias/ppt3.png" alt="截图3"><br><font size="4" color="green"><a href="/medias/PPT_Model.rar">模板下载</a></font></p>]]></content>
      
      
      <categories>
          
          <category> 测试管理 </category>
          
          <category> PPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOBDD如何在实际项目中的生根落地</title>
      <link href="/2018/11/30/2018-11-30-oobdd-ru-he-zai-shi-ji-xiang-mu-zhong-de-sheng-gen-luo-di/"/>
      <url>/2018/11/30/2018-11-30-oobdd-ru-he-zai-shi-ji-xiang-mu-zhong-de-sheng-gen-luo-di/</url>
      
        <content type="html"><![CDATA[<p><font size="8">自从</font>敏捷开发被引入后，似乎一夜之间所有的软件活动都在围绕着敏捷展开，的确敏捷开发给软件生产带来了极大的效率提升，敏捷开发只是一种软件生产的方法论，它鼓励各相关方（如开发，测试，QA，客户，市场等等）积极参与，以目标为导向，逐一分解功能目标，最终达成需求的目的。围绕敏捷开发的实现，也产生了不同的作业形态和实践类型，如早前的TDD，BDD，所谓TDD，即以测试驱动开发，在先于编码之前实现单元测试用例代码，根据测试代码确定最终的编码方案，这种类型可以尽早的发现问题，提高代码开发质量；另一种是BDD，即行为驱动开发，就是在编码前先确定有哪些场景和行为需要实现，定义好各个需要实现的模块的颗粒度，然后在利用TDD的模式进入确定最终的编码方案，那么如何定义好BDD的颗粒度？在业界没有统一的标准，个人认为合适就好，当然这个合适前提是要得到各相关方认可的。下图是BDD实践框架流程图，图片来自<a href="https://blog.csdn.net/chancein007/article/details/53933874">网络</a>仅供参考！</p><h4 id="BDD架构流程图"><a href="#BDD架构流程图" class="headerlink" title="BDD架构流程图 -"></a>BDD架构流程图 -</h4><p><img src="/medias/BDD.png" alt="BDD"></p><p>这里我要介绍的是另一种敏捷实践OOBDD，这是一种更加符合敏捷思维的实践模式，尽管很早就有这种概念的提出，但市场是能提供OOBDD的产品少之又少，今天给大家介绍一款国内首家将OOBDD实践落地的产品SpecMap,个人认为这是迄今我看到的最好的OOBDD实践产品，真正做到了面向对象的开发和测试有机结合，又能基于需求原型的对象提取，打通了从需求到测试验收的全环节面向对象的过程分析。因为是初次接触，很多功能正在摸索阶段，为避免以偏概全，这里我就其原理做一个简单介绍，有兴趣的童鞋可以点击文章的最后下载试用，操作简便，上手很容易，相信您一定会有惊喜的发现。</p><span id="more"></span><p>SpecMap OOBDD Workflow -</p><ol><li>新建项目，创建实体类别（entity）即需要测试的页面</li><li>在每个实体类别（entity）中直接载入需要测试的页面</li><li>识别测试对象，通常就是页面中的常见元素（如输入框，按钮，下拉框，组合框等常用元素）</li><li>分析对象属性</li><li>分析对象行为</li><li>分析行为之间的联系</li><li>创建测试集和生成测试用例（根据上面的对象行为自动生成测试用例）</li></ol><p>**** 简要演示图如下 - ****<br><img src="/medias/SpecMap/01.JPG" alt="demo_pic01"><br><img src="/medias/SpecMap/02.JPG" alt="demo_pic02"><br><img src="/medias/SpecMap/03.JPG" alt="demo_pic03"><br><img src="/medias/SpecMap/04.JPG" alt="demo_pic04"><br><img src="/medias/SpecMap/05.JPG" alt="demo_pic05"><br><img src="/medias/SpecMap/06.JPG" alt="demo_pic06"><br><img src="/medias/SpecMap/07.JPG" alt="demo_pic07"><br><img src="/medias/SpecMap/08.JPG" alt="demo_pic08"></p><p>*** refer to the spec - ***<br><a href="/medias/SpecMap/SpecMap%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf">Specification document</a></p><p><font red="red" size="4"><a href="https://pan.baidu.com/s/1y6AUhGcGIWzXUuq2KW_u4A">下载SpecMap</a> 提取码: eeyr</font></p><font red="red" size="4"></font>]]></content>
      
      
      <categories>
          
          <category> TDD </category>
          
          <category> BDD </category>
          
          <category> OOBDD </category>
          
          <category> DDT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDD </tag>
            
            <tag> BDD </tag>
            
            <tag> OOBDD </tag>
            
            <tag> DDT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to use Python PIL in graphic processing&quot;</title>
      <link href="/2018/11/07/2018-11-07-how-to-use-python-pil-in-photographic-cransaction/"/>
      <url>/2018/11/07/2018-11-07-how-to-use-python-pil-in-photographic-cransaction/</url>
      
        <content type="html"><![CDATA[<p>PIL(Python Image Library)是python中用来处理图形的专用模块，PIL提供的方法很全面，尽管没有专用图形软件如PS，Croeldraw，Adobe那么强大，但应付日常的图片操作还是足够的，并且借助Python脚本来处理，能极大地提高图形编辑效率，对于喜欢自动化的人来说，怎能缺少对这一块的认识？</p><p>PIL的常用操作不外乎这几种 -</p><ul><li>新建图片</li><li>编辑图片（大小裁剪，几何变换，像素处理，颜色转换，图像增强，类型转换，复制粘贴等）</li><li>分裂和合并</li><li>点运算</li><li>读序列<br>等等， 这里我就不一一介绍了，直接用几个实际例子来加以说明，这些代码在我本地是能跑通的，如有兴趣，读者可将此代码逐一调试，这样才能建立起深刻的认识，一起来看下 -</li></ul><span id="more"></span><p><b><font color="red">PIL图像读取和保存</font></b></p><b><font color="red"><pre class="line-numbers language-none"><code class="language-none">from PIL import Imageimport tkinter as tk# picPath = r'C:\Users\Luck_Lello\Pictures\release1.jpg'picPath = r'C:\Users\Luck_Lello\Desktop\IMG_0072.JPG'im = Image.open(picPath)im.save(r'C:\Users\Luck_Lello\Desktop\original.JPG') # 保存图片width, height = im.size# 宽高print "输入出该图片的尺寸 - ", im.size, width, height# 格式，以及格式的详细描述print "该图片的格式 - ", im.format, "及其图片描述 - ", im.format_description<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b><font color="red">PIL新建图像</font></b></p><b><font color="red"><pre class="line-numbers language-none"><code class="language-none">'''新建图像'''newIm = Image.new('RGB', (100, 100), 'red')newIm.save(r'C:\Users\Luck_Lello\Desktop\tempFolder\001.png')blcakIm = Image.new('RGB', (200, 100), 'red')blcakIm.save(r'C:\Users\Luck_Lello\Desktop\tempFolder\002.png')blcakIm = Image.new('RGBA', (300, 100), '#A0a010')blcakIm.save(r'C:\Users\Luck_Lello\Desktop\tempFolder\003.png')blcakIm = Image.new('CMYK', (400, 100), (255, 0, 0, 255))blcakIm.save(r'C:\Users\Luck_Lello\Desktop\tempFolder\004.jpg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b><font color="red">PIL裁剪图像</font></b></p><b><font color="red"><pre class="line-numbers language-none"><code class="language-none">'''裁剪图像'''picPath2 = r'C:\Users\Luck_Lello\Desktop\avatar1.JPG'im = Image.open(picPath2)cropedIm = im.crop((300, 100, 700, 540)) # left, upper, right, below - 后两个值必须比前面两个值要大cropedIm.save(r'C:\Users\Luck_Lello\Desktop\tempFolder\cropedAvatar1.jpg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b><font color="red">PIL粘贴及几何转换</font></b></p><b><font color="red"><pre class="line-numbers language-none"><code class="language-none">'''复制与粘贴图像到另一个图像'''im = Image.open(picPath2)cropedIm = im.crop((270, 160, 440, 300)) # left, upper, right, below - 后两个值必须比前面两个值要大cropedIm = cropedIm.transpose(Image.ROTATE_180)cropedIm = cropedIm.transpose(Image.FLIP_TOP_BOTTOM)# cropedIm = 'C:\Users\Luck_Lello\Desktop\tempFolder\cropedAvatar1.jpg'  # paste 方法中第一个参数必须是用4个数字定义的区域 use 4-item box, 不能是一个文件路径，否则类型不对im.paste(cropedIm, (474, 163)) # paste 方法中第一个参数必须是用4个数字定义的区域 use 4-item box, 不能是一个文件路径，否则类型不对# im.show() # 查看图片显示效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b><font color="red">PIL图片叠加</font></b></p><b><font color="red"><pre class="line-numbers language-none"><code class="language-none">''''两张图片相加'''picPath3 = r'C:\Users\Luck_Lello\Desktop\tempFolder\001.png'picPath4 = r'C:\Users\Luck_Lello\Desktop\tempFolder\002.png'img1 = Image.open(picPath3)img1 = img1.convert('RGBA')# img2 = Image.open(r"C:\Users\Luck_Lello\Desktop\tempFolder\lelloAvatar1.jpg")img2 = Image.open(picPath4)img2 = img2.convert('RGBA')img = Image.blend(img2, img2, 0.4) # 貌似要两张一样的图片# img.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b><font color="red">PIL图片整合</font></b></p><b><font color="red"><pre class="line-numbers language-none"><code class="language-none">'''将当前文件夹中的图片拼凑成一整张图片'''from os import listdir; from PIL import Image# 获取当前文件夹中的所有后缀为.jpg 的图片path = "C:\Users\Luck_Lello\Pictures"imgs = listdir(path) # 列出目标文件夹里所包含的所有文件名（无论文件还是文件夹）objImgs = []# 将目标文件夹里所有后缀为jpg的图片，装入objImgs列表for fn in imgs:if fn.endswith(".jpg"):objImgs.append(fn)print "打印jpg文件列表", objImgs# 单幅图片尺寸im = Image.open(path + "\\" + objImgs[0])mode = im.modeprint "mode is ", modewidth, height = im.sizeprint "width and height are ", width, height# 创建空白长图，长度为objImage列表中所有图片的总长result = Image.new(mode, (width, (height+5) * len(objImgs)), "red")# 拼接objImgs列表中所有的图片# for i, im in enumerate(objImgs): # enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中# result.paste(Image.open(path + "\\" + objImgs[i]), box=(0, (i * height)+23))# # result.paste((path + "\\" + objImgs[i]), box=(0, i * height)) # 这样写不行的，提示can't determine region size, use 4-item box, 所以只能讲图片打开后才能识别其region区域for i in range(1, 10):result.paste(Image.open(path + "\\" + objImgs[i]), box=(0, (i * height) + 23))# 保存拼接长图result.save(path + "\\" + "result.jpg")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></font></b></font></b></font></b></font></b></font></b></font></b>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> PIL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Webdriver API introduction</title>
      <link href="/2018/10/15/2018-10-15-python-webdriver-api-introduction/"/>
      <url>/2018/10/15/2018-10-15-python-webdriver-api-introduction/</url>
      
        <content type="html"><![CDATA[<p>首先，简要介绍下什么是WebDriver，WebDriver是selenium RC的替代品，考虑到selenium的兼容性，selenium RC并没有被彻底抛弃，如果你使用selenium开发一个新的自动化测试项目，强烈建议你使用WebDriver，那么WebDriver和selenium RC区别在哪里呢？</p><p>selenium RC 在浏览器中运行 JavaScript（seleniumCore，一堆JS的函数集合） 应用，使用浏览器内置的 JavaScript 翻译器来翻译和执行selenese 命令（selenese 是 selenium 命令集合）并把浏览器的代理设置为 Selenium Server 的<br>Http Proxy。（也就是说selenium RC可以看成是由这三部分组成的：client, selenium core, Http Proxy）; 而WebDriver 通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver 针对各个浏览器而开发，取代了嵌入到被测 Web 应用中的 JavaScript。与浏览器的紧密集成支持创建更高级的测试，避免了JavaScript 安全模型导致的限制。除了来自浏览器厂商的支持，WebDriver 还利用操作系统级的调用模拟<br>用户输入。</p><p>可以这么认为，selenium是一个浏览器自动化测试框架，它主要是用于 Web 应用程序的自动化测试（实际应该远不止于Web应用程序的测试）。而Selenium WebDriver提供了各种语言环境的API来支持更多控制权和编写符合标准软件开发实践的应用程序。通常我们认为selenium包含selenium IDE（主要用于Firefox 浏览器的自动化脚本录制），selenium Grid（利用 Grid，可以很方便地同时在多台机器上和异构环境中并行运行多个测试事例）和 WebDriver（替代selenium RC）</p><span id="more"></span><p>下面重点梳理下WebDriver的常用操作实现</p><p><strong>浏览器操作</strong><br><font color="green">1. 最大化浏览器<br>#coding=utf-8<br>from selenium import webdriver<br>driver = webdriver.Ie()<br>driver.get(“<a href="http://www.sina.com&quot;/">www.sina.com"</a>)<br>#driver = webdriver.Firefox()<br>#driver.get(“<a href="http://www.sina.com&quot;/">http://www.sina.com"</a>)<br>print “浏览器最大化”<br>driver.maximize_window() #将浏览器最大化显示<br>driver.quit()</font></p><font color="green"><p><font color="green">2. 浏览器前进后退实现<br>#coding=utf-8<br>from selenium import webdriver<br>import time<br>driver = webdriver.Ie()<br>driver.get(“<a href="http://www.sina.com&quot;/">www.sina.com"</a>)<br>#访问sina首页<br>first_url= ‘<a href="http://www.sina.com&amp;/#39;">http://www.sina.com'</a><br>print “now access %s” %(first_url)<br>.get(first_url)<br>time.sleep(2)<br>#访问sina页面<br>second_url=’<a href="http://news.sina.com&amp;/#39;">http://news.sina.com'</a><br>print “now access %s” %(second_url)<br>driver.get(second_url)<br>time.sleep(2)<br>#返回（后退）到sina首页<br>print “back to %s “%(first_url)<br>driver.back()<br>time.sleep(1)<br>#前进到新闻页<br>print “forward to %s”%(second_url)<br>driver.forward()<br>time.sleep(2)<br>driver.quit()</font></p><font color="green"><p><strong>测试对象操作</strong><br>一般来说，webdriver 中比较常用的操作对象的方法有下面几个<br>   click 点击对象<br>   send_keys 在对象上模拟按键输入<br>   clear 清除对象的内容，如果可以的话<br>   submit 清除对象的内容，如果可以的话<br>   text 用于获取元素的文本信息<br>对于这些常用对象的脚本设计，这里我给出几个实例，以加深印象，事实上大部分的实际应用和这里的用法大同小异，另外在实际使用这些对象时，要习惯查阅WebDriver手册，如此反复才能做到得心应手。下面以百度搜索为例，看这些对象是如何在代码中被使用的。<br>from selenium import webdriver<br>import time<br>driver = webdriver.Firefox()<br>driver.get(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com"</a>)<br>#通过 clear()、send_keys() 来操作<br>driver.find_element_by_id(“kw”).clear()<br>driver.find_element_by_id(“kw”).send_keys(“selenium”)<br>time.sleep(2)<br>#通过 submit() 来操作<br>driver.find_element_by_id(“su”).submit()<br>time.sleep(3)<br>#id = cp 元素的文本信息<br>data=driver.find_element_by_id(“cp”).text<br>print data #打印信息<br>time.sleep(3)<br>#通过 click() 来操作<br>driver.find_element_by_id(“login”).click()<br>#也可定位登陆按钮，通过 enter（回车）代替 click()<br>driver.find_element_by_id(“login”).send_keys(Keys.ENTER)</p><p><strong>定位测试元素</strong><br>TBC…</p></font></font>]]></content>
      
      
      <categories>
          
          <category> python自动化 </category>
          
          <category> selenium </category>
          
          <category> Webdriver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自动化 </tag>
            
            <tag> selenium </tag>
            
            <tag> Webdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common KP and Concepts analysis of Python</title>
      <link href="/2018/10/11/2018-10-11-common-kp-and-concepts-analysis-of-python/"/>
      <url>/2018/10/11/2018-10-11-common-kp-and-concepts-analysis-of-python/</url>
      
        <content type="html"><![CDATA[<p>函数在Python中应用十分广泛，它是Python高级应用的基础，网上介绍Python函数的资料枚不胜举，这里我重点梳理下Python函数的几个常用概念和相关知识点以及使用注意事项 -</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><pre class="line-numbers language-none"><code class="language-none">def power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>上面是一个常见的函数定义，关键字def，函数名，以及后面的小括弧一个都不能少，还有别忘了后面的冒号：</li></ul><ul><li>函数体及代码块是在冒号缩进后开始写的</li></ul><ul><li>语句return [expression] 用于退出一个函数，可选地将一个表达式传回给调用者。如果没有使用参数的return语句，则它与return None相同。<span id="more"></span></li></ul><p><strong>函数的参数</strong></p><ol><li>默认参数<br>调用上面的函数，只需给出x和n的初始值就行了，如果把上面函数的参数写成 def power(x, n=3)，那么就是参数的默认化，此时调用函数只需给出x值就可以了。当我们调用power(5)时，相当于调用power(5, 3)</li></ol><p> <font color="red">如果有默认参数，则必选参数在前，默认参数在后，否则Python的解释器会报错<br> 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数（即给出该参数的初始值）。</font></p><font color="red"><ol start="2"><li><p>可变参数</p><pre class="line-numbers language-none"><code class="language-none">def calc(*numbers):     sum = 0     for n in numbers:         sum = sum + n * n     return sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可变字参数，就是在参数前加了一个 * 号，这样一来，在调用该函数时，可以传入任意个参数也可以给出0个。<br>可变参数允许你传入0个或任意个参数，<em><strong>这些可变参数在函数调用时自动组装为一个tuple</strong></em>。</p></blockquote></li><li><p>关键字参数</p><pre class="line-numbers language-none"><code class="language-none">def person(name, age, **kw):   print 'name:', name, 'age:', age, 'other:', kw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p></blockquote></li></ol><blockquote><p>关键字参数的用处主要表现在，它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p></blockquote><ol start="4"><li>组合函数<br>在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。</li></ol><ol start="5"><li>匿名函数<br>关键字lambda表示匿名函数，lambda [arg1 [,arg2,…..argn]]:expression 冒号前面的x表示函数参数。看下面一个例子<pre class="line-numbers language-none"><code class="language-none">a = map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])等同于这个表达式 -def f(x):&nbsp;&nbsp;&nbsp;&nbsp;return x * x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>lambda只是一个表达式，不是一个代码块，函数体比def简单很多，只能封装有限的逻辑，可以起到速写函数的作用</li></ol><ol start="6"><li><p>闭包函数<br>就是函数内部定义的函数，并且包含了对外部作用域的引用。下面的例子能很好的帮助阐述什么是闭包函数。</p><pre class="line-numbers language-none"><code class="language-none"># 这个不是闭包函数def functionA():    def inner():        print "this is the inner outputs"    inner()    print "this is the functionA outputs"# 这个也不是闭包函数x = 1def functionA():    def inner():        print "this is the inner outputs"    inner()    print "this is the functionA outputs"# 只有这个才是闭包函数  def functionA():    x = 1    def inner():        print "this is the inner outputs"    inner()    print "this is the functionA outputs"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>装饰函数<br>装饰函数就是在不更改原函数任何代码的情况下通过引用原函数来丰富原函数的功能的函数。也可以这么表述</p></li></ol><ul><li>装饰器：外部函数传入被装饰函数名，内部函数返回装饰函数名。</li></ul><ul><li>特点：1.不修改被装饰函数的调用方式 2.不修改被装饰函数的源代码</li></ul><p>还是有点晦涩，来看个例子吧 -</p><pre class="line-numbers language-none"><code class="language-none">def decoration(func):    def inner(a, b, c):        print "\n\n\n", "*" * 40        func(a, b, c)        print "*" * 40    return inner@decorationdef functionA(a, b, c):    print "count an addition result - \na + b + c = ", a + b + cfunctionA(3, 5, 7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子中，functionA被作为参数传入decoration(func)，执行inner函数后再传回给调用的函数。要装饰的功能在inner函数中实现。</p></font>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> Python常用知识点解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python在数据库中的应用</title>
      <link href="/2018/09/23/2018-09-23-python-zai-shu-ju-ku-zhong-de-ying-yong/"/>
      <url>/2018/09/23/2018-09-23-python-zai-shu-ju-ku-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p>数据库应用也是python一个重要的应用场景，通过python连接数据库，执行SQL语句获取返回句柄，将返回句柄保存在excel中，然后对这些保存的数据进行操作，是比较常见的应用模式。今天重点介绍下python在数据库中的常见操作实现，掌握了这些基本技能，也就能驾驭大部分的python数据库应用场景。</p><span id="more"></span><h5 id="1-导入Python-mysql模块pymysql"><a href="#1-导入Python-mysql模块pymysql" class="headerlink" title="1. 导入Python mysql模块pymysql -"></a>1. 导入Python mysql模块pymysql -</h5><pre class="line-numbers language-none"><code class="language-none">import pymysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="1-1-mySQL数据库连接-​"><a href="#1-1-mySQL数据库连接-​" class="headerlink" title="1.1 mySQL数据库连接 -  ​"></a>1.1 mySQL数据库连接 -  ​</h6><pre class="line-numbers language-none"><code class="language-none">conn = pymysql.connect(host='localhost',                       port=3306,                       user='root',                       passwd='123456',                       db='msg',                       charset='utf8',                       autocommit=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="1-2-数据库常见操作实现（CDMU）"><a href="#1-2-数据库常见操作实现（CDMU）" class="headerlink" title="1.2 数据库常见操作实现（CDMU）"></a>1.2 数据库常见操作实现（CDMU）</h6><pre class="line-numbers language-none"><code class="language-none">def create_tb(self):        """        建表        """        with Foo.conn.cursor() as cursor:            cursor.execute("""                drop table if exists tb_addrBook;                create table tb_addrBook(                pid int auto_increment,                name varchar(20) not null,                sex char(5) default '男',                tel char(11) not null,                addr varchar(30),                primary key (pid)                );""")​    def insert(self):        """        插入内容        :return:        """        temp = True        while temp:            name = input('请输入姓名:')            sex = input('性别(男-1/女-0):')            if sex == '1':                sex = '男'            elif sex == '0':                sex = '女'            else:                temp = False                print('输入有误, 重新输入!!')            tel = input('电话号码:')            addr = input('家庭住址:')            with Foo.conn.cursor() as cursor:                cursor.execute("""insert into tb_addrBook (name, sex, tel, addr)                                        values(%s, %s, %s, %s)""",(name, sex, tel, addr))            temp = input('是否还要继续增加? 是(1) 否 (0)' )            if temp == '0':                temp = False​    def update(self):        """        将电话号码改为 0000000000        """        print('输入您要更新的姓名!')        name = input('姓名:')        with Foo.conn.cursor() as cursor:            cursor.execute('update tb_addrBook set tel="00000000000" where name=%s', (name, ))​    def delate(self):        """        删除联系人        """        print('输入您要删除的姓名!')        name = input('姓名:')        with Foo.conn.cursor() as cursor:            cursor.execute('delete from tb_addrBook where name=%s',(name))​    def select(self):        """        查找        """        print('输入您要查找的姓名!')        name = input('姓名:')        with Foo.conn.cursor() as cursor:            cursor.execute('select * from tb_addrBook where name=%s', (name))            b = cursor.fetchone()            print(b)​    def search(self):        in_msg = input('输入您要查找的姓名:')        with Foo.conn.cursor() as cursor:            msg = '%' + in_msg + '%'            cursor.execute('select pid, name,sex, tel, addr from tb_addrBook where name like %s', (msg,))            b = cursor.fetchall()            print('%10s %10s %15s %8s %10s' % ('pid', 'name', 'sex', 'tel', 'addr'))            for i in [*b]:                print('%03s %10s %10s %15s %8s' % (str(i[0]), i[1], str(i[2]), i[3], i[4]))​    def show(self):        with Foo.conn.cursor() as cursor:            cursor.execute('select pid, name, sex, tel, addr from tb_addrBook')            b = cursor.fetchall()            print('%03s %10s %10s %15s %8s' % ('编号(pid)', 'name', 'sex', 'tel', 'addr'))            for i in [*b]:                print('%03s %10s %10s %15s %8s' % (str(i[0]), i[1], str(i[2]), i[3], i[4]))​    def commit(self):        """提交"""        Foo.conn.commit()​    def rollback(self):        """回滚"""        Foo.conn.rollback()​    def close(self):        """关闭连接"""        Foo.conn.close()​​def main():    foo = Foo()    try:        foo.create_tb()        while False:            foo.show()            print('增加(1) 修改(2) 查找(3) 删除(4) 退出(5)')            ope = input('选择:')            if ope == '1':                foo.insert()                foo.commit()            elif ope == '2':                foo.update()                foo.commit()            elif ope == '3':                foo.search()            elif ope == '4':                foo.delate()                foo.commit()            else:                break    except:        foo.rollback()    finally:        foo.close()​​if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="reference-Blog"><a href="#reference-Blog" class="headerlink" title="reference Blog -"></a>reference Blog -</h6><p><a href="https://blog.csdn.net/zhang_Ming_lu/article/details/80835797?utm_source=copy">https://blog.csdn.net/zhang_Ming_lu/article/details/80835797?utm_source=copy</a></p>]]></content>
      
      
      <categories>
          
          <category> python自动化 </category>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python在Ajax中的应用</title>
      <link href="/2018/09/23/2018-09-23-python-zai-ajax-zhong-de-ying-yong/"/>
      <url>/2018/09/23/2018-09-23-python-zai-ajax-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p>Ajax技术在网站中的应用随处可见，python要提取网页中的内容，就需要模拟动态的网页加载，对于动态页面信息的爬取，一般分为两种情况，一种是直接从JavaScript中采集加载的数据、需要自己去手动分析Ajax请求来进行信息的采集，另一种则是直接从浏览器中采集已经加载好的数据、即可以使用无界面的浏览器如PhantomJS来解析JavaScript。</p><p>这里重点介绍下Python如何模拟Ajax请求采集加载JavaScript的数据，从而获取网页内容 -</p><span id="more"></span><h5 id="1-通过给定的url获取页面文本"><a href="#1-通过给定的url获取页面文本" class="headerlink" title="1. 通过给定的url获取页面文本"></a>1. 通过给定的url获取页面文本</h5><pre class="line-numbers language-none"><code class="language-none">url = r"https://www.toutiao.com/search/?keyword=%E8%A1%97%E6%8B%8D"req = requests.get(url)html = req.textreload(sys)sys.setdefaultencoding("utf-8")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-将url源代码保存在htmlfile文件里，方便查看提取内容"><a href="#2-将url源代码保存在htmlfile文件里，方便查看提取内容" class="headerlink" title="2. 将url源代码保存在htmlfile文件里，方便查看提取内容"></a>2. 将url源代码保存在htmlfile文件里，方便查看提取内容</h5><pre class="line-numbers language-none"><code class="language-none">saveHtmlFile = "C:\Users\Luck_Lello\Desktop\saveHtmlFile"fo = open(saveHtmlFile + "\htmlFile.html", 'w+')fo.write(html)fo.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-通过url得到的html没有需要的图片，分析这些图片是由XHR（Ajar）生成的，所以构造Ajax请求页面，获得需要的图片目标"><a href="#3-通过url得到的html没有需要的图片，分析这些图片是由XHR（Ajar）生成的，所以构造Ajax请求页面，获得需要的图片目标" class="headerlink" title="3. 通过url得到的html没有需要的图片，分析这些图片是由XHR（Ajar）生成的，所以构造Ajax请求页面，获得需要的图片目标"></a>3. 通过url得到的html没有需要的图片，分析这些图片是由XHR（Ajar）生成的，所以构造Ajax请求页面，获得需要的图片目标</h5><pre class="line-numbers language-none"><code class="language-none">from urllib import urlencodeoffset = 20params = {'offset': offset, 'format': 'json', 'keyword': '街拍', 'autoload': 'true', 'count':'20', 'cur_tab': '1' }url = "https://www.toutiao.com/search_content/?" + urlencode(params)print url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-保存Ajax请求后的页面，然后就可以基于该页面做静态内容的提取了"><a href="#4-保存Ajax请求后的页面，然后就可以基于该页面做静态内容的提取了" class="headerlink" title="4. 保存Ajax请求后的页面，然后就可以基于该页面做静态内容的提取了"></a>4. 保存Ajax请求后的页面，然后就可以基于该页面做静态内容的提取了</h5><pre class="line-numbers language-none"><code class="language-none">response = requests.get(url)htmlContent = response.textfo = open(saveHtmlFile + "\htmlFile.html", 'w+')fo.write(htmlContent)fo.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h4><ul><li><p>从头条街拍信息中提取相应的图片，请看代码实现</p><pre class="line-numbers language-none"><code class="language-none"># try:#     response = requests.get(url)#     if response.status_code == 200:#         getConn = response.json()# except requests.ConnectionError:#     print "Linkage is not available"# import re# reg = re.search('\d:\s{url:\s"(.*?)"}', htmlContent, re.S)## print regimport requestsdef get_page(offset):    params = {        'offset': offset,        'format': 'json',        'keyword': '街拍',        'autoload': 'true',        'count': '20',        'cur_tab': '1',    }    url = 'http://www.toutiao.com/search_content/?' + urlencode(params)    try:        response = requests.get(url)        if response.status_code == 200:            return response.json()    except requests.ConnectionError:        return Nonedef get_images(json):    if json.get('data'):        for item in json.get('data'):            title = item.get('title')            images = item.get('image_detail')            for image in images:                yield {                    'image': image.get('url'),                    'title': title                }import osfrom hashlib import md5def save_image(item):    if not os.path.exists(item.get('title')):        os.mkdir(item.get('title'))    try:        response = requests.get(item.get('image'))        if response.status_code == 200:            file_path = '{0}/{1}.{2}'.format(item.get('title'), md5(response.content).hexdigest(), 'jpg')            if not os.path.exists(file_path):                with open(file_path, 'wb') as f:                    f.write(response.content)            else:                print('Already Downloaded', file_path)    except requests.ConnectionError:        print('Failed to Save Image')from multiprocessing.pool import Pooldef main(offset):    json = get_page(offset)    for item in get_images(json):        print(item)        save_image(item)GROUP_START = 1GROUP_END = 20if __name__ == '__main__':    pool = Pool()    groups = ([x * 20 for x in range(GROUP_START, GROUP_END + 1)])    pool.map(main, groups)    pool.close()    pool.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> python自动化 </category>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自动化 </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python静态页面爬虫</title>
      <link href="/2018/09/22/2018-09-22-python-jing-tai-ye-mian-pa-chong/"/>
      <url>/2018/09/22/2018-09-22-python-jing-tai-ye-mian-pa-chong/</url>
      
        <content type="html"><![CDATA[<p>爬虫技术随着网络的普及和广泛应用，也得到了极大的发展，互联网上有着无数的网页，如何从海量页面中快速的获取信息，是需要思考和解决的问题，这也促使了网络爬虫技术的发展，从一个页面到另一个页面，从一个站点到另一个站点，就像蜘蛛织网一样，因此网络爬虫也形象的称之为网络蜘蛛，也叫网络机器人。</p><span id="more"></span><p>理论上讲，任何支持网络通讯的语言都可以用来做爬虫，写爬虫与编程语言的关联性不大，但总有相对顺手，便捷的语言，Python无疑是其中的一种，其广泛地应用于爬虫编写，也诞生了很多优秀的爬虫框架，如Scrapy, PySpider, Crawley, Portia, Beautiful Soup, Grab等等，熟练地使用这些框架可以帮助人们快速的开发爬虫应用，有关这些框架的使用和技术介绍，网上有大量的文献，在这里不作讨论。今天我要给大家介绍的是通过另一种方式快速简便的实现爬虫应用 - 正则表达式。这种方式在应对静态HTML页面时特别有效，下面通过一个实例来简单介绍下，希望能起到举一反三的作用。</p><p><font size="5" color="red">正则表达式在python爬虫中的应用</font></p><font size="5" color="red"><pre class="line-numbers language-none"><code class="language-none">url = "https://image.baidu.com/search/index?tn=baiduimage&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;ie=gb18030&amp;word=%C3%C0%C9%D9%B8%BE&amp;fr=ala&amp;ala=1&amp;alatpl=cover&amp;pos=0&amp;hs=2&amp;xthttps=111111"# url = "http://www.360doc.com/content/17/0203/19/12472239_626276344.shtml"# url = "http://www.360doc.com/userhome/12472239"# url = "http://www.360doc.com/content/18/0708/00/12472239_768657823.shtml"from selenium import webdriverfrom selenium.webdriver.common.keys import Keys# driver = webdriver.Ie()# driver.get("www.baidu.com")# driver.find_element_by_id("kw").send_keys(u"美少妇")# driver.find_element_by_id("su").send_keys(Keys.ENTER)import urllib, requests# getURL = urllib.urlopen(url)# html = getURL.read() # 有时现实的html中文是乱码，下面的写法能正确显示html文档req = requests.get(url)# html = req.texthtml = req.content# print htmlimport re# reg = r'data-imgurl="(.+?\.jpg)" /&gt;'# reg = r'src="(.+?\.jpg)" pic_ext'reg = r'src="(.+?\.jpg)"\s/&gt;'pattern = re.compile(reg)imglist = re.findall(pattern, html)print "how many pictures found - ", len(imglist)x = 1savePictureFolder = "C:\Users\Luck_Lello\Desktop\SavePythonSpiderPictures"for i in imglist:    print i    urllib.urlretrieve(i, savePictureFolder + "\\%s.jpg"%(x))    x += 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上内容是根据html内容来抓取图片的，对于一些静态页面html比较有效，对shtml没多大用处。但此时也可以先模拟js行为，然后在抓取页面内容进行类似处理。</p><p>这个例子告诉我们，做事情有时不能太拘泥于形式和框架，经验固然重要，但还是要具体问题具体分析，解决问题最有效的方式有时就是最不麻烦的方式，测试尤其如此。</p><p><b><font color="blue"><a href="https://www.cnblogs.com/sss4/p/7809821.html">一篇不错的参考文档 -</a></font></b><font color="blue"><br><img src="/medias/spider.png" alt="盗张图~~~"></font></p><font color="blue"></font></font>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 页面爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 测试报告研究</title>
      <link href="/2018/09/22/2018-09-22-python-ce-shi-bao-gao-yan-jiu/"/>
      <url>/2018/09/22/2018-09-22-python-ce-shi-bao-gao-yan-jiu/</url>
      
        <content type="html"><![CDATA[<p><font size="4" color="red"><b>HTMLTestRunner</b></font><b> 是Python的一个标准库，是unittest单元测试的一个框架扩展，顾名思义可以用它来生成漂亮的单元测试报告，千万别小看测试报告，赏心悦目的报告能给测试增色不少，一起来看看HTMLTestRunner是如何工作的吧 -</b></p><b><p><b>下载和安装</b><br>有两种方式，一种是直接pip管道安装</p><ol><li><p>pip install html_testRunner*.whl</p></li><li><p>另一种是直接<a href="https://pypi.python.org/pypi/HTMLTestRunner">官网下载</a>testruner相应的py文件（Python 模块文件），然后放在安装目录的lib下即可windows:下载HTMLTestRunner.py 文件,放在python目录下的lib文件夹, 例如\Python27\Lib</p></li></ol><p><b>实例参考</b></p><ol><li><p>下面给出一个使用例子，这也是单元测试的常见写法，请留意</p></li><li><p>1 引入相关模块（modules）</p><pre class="line-numbers language-none"><code class="language-none"># -*- coding:utf-8 -*-import unittestimport HTMLTestRunner,sys,StringIO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><span id="more"></span></li><li><p>2 单元测试用例实现</p><pre class="line-numbers language-none"><code class="language-none">#测试用例  class MyTestCase(unittest.TestCase):     def setUp(self):         pass     def tearDown(self):         pass     def testCase1(self):         self.assertEqual(2,3,"thest both number are not equal, so, this message should show here")     def testCase2(self):         self.assertNotEqual(2,3,"the both number i given are not equal. so here this message should show here!")     def testCase3(self):         self.assertIs('a', 'a', "'a' is  'a', so assert 'self.assertIs(a, a, msg)'shouldn't show this message.")     def testCase4(self):         self.assertIn('y', 'Alan', "error message - self.assertIn('y', 'Alan', 'msg') doesn't work here, so show this message")     def TestCase5(self):         self.assertNotIn('a', 'Alan', "error message -  self.assertNotIn('a', 'Alan', 'msg') doesnt work, so show this message")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>3 #添加Suite</p><pre class="line-numbers language-none"><code class="language-none">def Suite():    suiteTest = unittest.TestSuite()    suiteTest.addTest(MyTestCase("testCase1"))    suiteTest.addTest(MyTestCase("testCase2"))    suiteTest.addTest(MyTestCase("testCase3"))    suiteTest.addTest(MyTestCase("testCase4"))    suiteTest.addTest(MyTestCase("TestCase5"))    return suiteTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>  1.4 调用TestRunner生成测试报告<br>  </p><pre class="line-numbers language-none"><code class="language-none">if __name__ == '__main__':  #确定生成报告的路径  filePath = "c:/Users/Luck_Lello/Desktop/pyResult.html"  fp = file(filePath,'wb')  #生成报告的Title,描述  runner = HTMLTestRunner.HTMLTestRunner(stream=fp,title='Automation Test Report for Python',description='This is the Report created by Alan.Yuan')  runner.run(Suite())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p><b>小结：</b><br>    这个基本上就是HTMLTestRunner模块的基本用法，当然报表生成后，还可以对其进行美化，结合css和pyechart可以做出更加生动的报告来。关于这部分的结合，下次有机会再继续分享.</p></blockquote></b>]]></content>
      
      
      <categories>
          
          <category> python自动化 </category>
          
          <category> python 测试报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 测试报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Python设计专业的工作报告</title>
      <link href="/2018/09/19/2018-09-19-ru-he-yong-python-she-ji-zhuan-ye-de-gong-zuo-bao-gao/"/>
      <url>/2018/09/19/2018-09-19-ru-he-yong-python-she-ji-zhuan-ye-de-gong-zuo-bao-gao/</url>
      
        <content type="html"><![CDATA[<p>先来看下实例，这是我制作的月/季报模式，喜欢的话举个爪吧 ~~<br><font size="14"><a href="/medias/Retro.report/retrospective_Report.html">瞧瞧去！</a></font></p><font size="14"><p><font face="微软雅黑" color="red" size="3">设计思路：</font></p><font face="微软雅黑" color="red" size="3"><ul><li><font face="Gill Sans MT" color="#B20000"> 收集整理数据 -&gt; 将数据转换为Python Echart图表 -&gt; 设计Html报告页，将echart图标统一展示</font></li><font face="Gill Sans MT" color="#B20000"><li><img src="/medias/pythonEchart.png" alt="设计思路"></li></font></ul><font face="Gill Sans MT" color="#B20000"><span id="more"></span><p>这里重点还是Python Echart图表的使用上，废话不说，直接上步骤吧 -</p><ol><li>安装python （这个不用我多说了吧 ~~）</li><li>安装python pip (这个一般在安装python时会一并安装的，pip类似于node.js的npm，是python的一个包安装器，有了它会省去我们安装python的不少麻烦，至少不用单独下载安装包)</li><li>安装echart （pip install pyechart）</li><li>调用echart图标（下面详细说说这个的用法）</li></ol><p>Python Echart 使用详解</p><pre class="line-numbers language-none"><code class="language-none">from pyecharts import Bar, Line, Grid, Overlap, EffectScatter, Pie''' 1. *** 测试项目TCs 统计&gt;&gt;  下图实例找齐了Pie, Bar, Line 图常用的修改参数，请参考&gt;&gt;  下面各图表的参数设置，实际使用中并不是全部必须的，列在这里仅供参考***'''# from pyecharts import Bar, Line, Pie, Overlap, EffectScatterattr1 = ['DEVDCMODULEMGT', 'GDS Service Portal AT', 'GDS运维管理', 'PPM Release1 AT', 'DCFM告警单验证AT', 'ECC集控中心', 'PPM Release2', 'CRS客户服务系统'] # 测试项目val1 = [59, 1, 7, 4, 2, 276, 0, 0] # 各项目测试用例设计量pcspie = Pie("TC Outputs Statistic", "各项目测试用例统计", width = 1200, height = 500) # title_pos="center"pie.add("TCs Output (单位:个)", attr1, val1,        legend_pos="2%", #  legend_pos : 图例位置 right, center, left, bottom, or X%        legend_top="25%",        is_label_show=True,        is_legend_show=True,        is_more_utils=True,        label_text_color=None, # 'red' or 'green', ....        legend_orient='vertical', # legend_orient='vertical' or 'horizontal'        radius=[30, 65], #环形内外圆的半径        is_label_emphasis=True,        legend_text_size=12,        # width=1200, -- 这里定义width和height对整体图示不起作用，应该在调用图示对象时定义        # height=600,        # rosetype='radius', # 有'radius'和'area'两种模式, radius：扇区圆心角展现数据的百分比，半径展现数据的大小。 area：所有扇区圆心角相同，仅通过半径展现数据大小。        center=[50, 52], # 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标，默认为 [50, 50]        legend_selectedmode=True, # 对图例点选操作禁止或打开)pie.render("1_ResourceforRetro/render1.html")''' 2. *** 测试项目effort 统计 ***'''# from pyecharts import Bar, Line, Pie, Overlapattr2 = ['DEVDCMODULEMGT', 'GDS Service Portal AT', 'GDS运维管理', 'PPM Release1 AT', 'DCFM告警单验证AT', 'ECC集控中心', 'PPM Release2', 'CRS客户服务系统']val2= [72, 16, 8, 24, 32, 220, 0, 0] # unit：hoursbar = Bar("Test Effort Statistic", "各项目测试工时统计", width = 1200, height = 500)bar.add("工时 (单位:小时)", attr2, val2, is_more_utils=True,        is_label_show=True,        legend_pos="right",        legend_top="5%",        width = 1200,        height = 600,        bar_category_gap="60%",        mark_point=['max', 'min'], # or 'average'        mark_line=['max'],        is_datazoom_show=True,        is_label_emphasis=True,)bar.render("1_ResourceforRetro/render2.html")''' 3. *** 测试项目Bugs 统计 ***'''# from pyecharts import Bar, Line, Pie, Overlapattr3 = ['DEVDCMODULEMGT', 'GDS Service Portal AT', 'GDS运维管理', 'PPM Release1 AT', 'DCFM告警单验证AT', 'ECC集控中心', 'PPM Release2', 'CRS客户服务系统']val3 = [28, 0, 3, 4, 0, 79, 0, 0] # unit: pcsline = Line("Test Bug Statistic", "各项目测试bug统计", width = 1200, height = 500)line.add("Bug (单位:个)", attr3, val3, is_more_utils=True,         # is_label_show=True,         # is_step=True,         yaxis_name=u"Bug 个数",         # xaxis_name="项目",         # xaxis_margin=5,         # xaxis_name_pos="80%",         # is_radiusaxis_show=True,         is_area_show= True,         label_text_size=10,         # label_color="#12F23",         legend_pos="right",         legend_top="5%",         mark_point=['max', 'min', 'average'], # or 'average'         mark_point_symbol='arrow', # or 'arrow'         # mark_point_symbolsize=10,         mark_point_textcolor='yellow',         mark_line=['max'],         mark_line_symbolsize=10,         line_width=5,         # line_type=5,         line_color='green',         area_opacity=0.8,         line_opacity=0.4,         symbol_size=3,         # is_datazoom_show=True,)es = EffectScatter("", width = 1200, height = 500)es.add("Bug statistic", attr3, val3,       symbol_size= 20,       effect_scale= 3.6,       effect_period= 3,       symbol= "pin",       is_label_show= True,       label_color="red")bar1 = Bar("", width = 1000, height = 400)bar1.add("", attr3, val3, is_label_show=True, bar_category_gap="40%")overlap = Overlap("", width = 1200, height = 500)overlap.add(line)overlap.add(es)# overlap.add(bar)overlap.render("1_ResourceforRetro/render3.html")"""使用Grid（）对象可以将python chart图并列编排，需要注意的是gird_left, right, height, width 参数的设置，由此引起的各chart图参数设置的调整，建议不要用百分比，这个容易引起显示错位下图被注释的代码基本达到了希望的效果"""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个图标的render语句会在当前脚本目录下生成一个该图标的html报告，如 - render(“1_ResourceforRetro/render3.html”)，此路径可自定义，默认是当前脚本路径，报告格式是html，不可改成其他类型。</p><p>获得了需要的图表报告后，接下来就是要将这些报告统一汇总在一张自定义的html文件中，下面是我上面demo图例中的自定义的html文件，不喜勿喷 @@@</p><pre class="line-numbers language-none"><code class="language-none">import os, sysfrom Common_Functions_Consolidation import *#1. create new path for retrosepective report and retrospective report will locate on the sme path with the scripts# **********************************************************************************************************************************************************scriptPath = os.getcwd()reportFilePath = os.path.join(scriptPath, "retrospective_Report.html")#2. Validate the folder ''htmlReport and see if it is being there already# **********************************************************************************************************************************************************print os.path.isdir("1_ResourceforRetro") # 文件夹名称是不分大小写的if os.path.isdir("1_ResourceforRetro") == False:    print "There is no folder of '1_ResourceforRetro' there, please ensure you got this folder first before running this script!"    sys.exit()#3. Define retrospective report form by python# **********************************************************************************************************************************************************reload(sys) # 这两句对字符一起可改变解析的字符编码风格sys.setdefaultencoding("utf-8") # 这两句对字符一起可改变解析的字符编码风格#3.1 define html header part of this report -#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------reportTitle = "测试线阶段工作汇总 - Apr. ~ Jul."pythonWriteHtml_to_File_Part1(reportFilePath, reportTitle)#3.2 define html body part which comes from 'htmlReport' of this report -#  --------------------------------------------------------------------------------------------------------------------------------------pythonWriteHtml_to_htmlReport(scriptPath, reportFilePath)# #3.3 define html body part which comes from 'htmlReport_1' of this report -# #  --------------------------------------------------------------------------------------------------------------------------------------# anotherProjectName = "DCFM 告警单重构"# addSecondProjectReport_Header(reportFilePath, anotherProjectName)# addSecondProjectReport_Body(scriptPath, reportFilePath)##4 define html ending part of this report -#  --------------------------------------------------------------------------------------------------------------------------------------python_WriteHtml_to_File_Part2(reportFilePath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是上面代码中引用的包（Common_Functions_Consolidation）的相关函数实现-</p><pre class="line-numbers language-none"><code class="language-none">def pythonWriteHtml_to_File_Part1(reportFilePath, reportTitle):    # reportFilePath 是一个.html文件，这个文件通常由调用脚本生成    fo = open(reportFilePath, "w+")  # 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。    # f.write("&lt;!DOCTYPE html&gt;\n")    # f.write("&lt;h1&gt;alan&lt;/h1&gt;")    # f.close()    htmlText = """&lt;!DOCTYPE html&gt;    &lt;html&gt;    &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;style type="text/css"&gt;    #header {        background-color:black;        color:white;        text-align:left;        padding:5px;        font-family:Gill Sans MT;        font-size:22px    }    #reportZone{        width:1550px;        &lt;!--这个可以取消，不影响效果 --&gt;        align:left;        padding:5px;        font-family:Gill Sans MT;        font-size:12px      }    .anotherProject{        background-color:black;        color:white;        text-align:left;        padding:5px;        font-family:Gill Sans MT;        font-size:20px    }    #footer {        background-color:black;        color:white;        font-family:Gill Sans MT;        font-size:9px        text-align:left;        padding:2px;    }    # for the animal text -    @keyframes blink{    0%{opacity: 1;}    50%{opacity: 1;}    50.01%{opacity: 0;}    100%{opacity: 0;}    }    @-webkit-keyframes blink {    0% { opacity: 1; }    50% { opacity: 1; }    50.01% { opacity: 0; }    100% { opacity: 0; }    }    @-moz-keyframes blink {    0% { opacity: 1; }    50% { opacity: 1; }    50.01% { opacity: 0; }    100% { opacity: 0; }    }    @-ms-keyframes blink {    0% { opacity: 1; }    50% { opacity: 1; }    50.01% { opacity: 0; }    100% { opacity: 0; }    }    @-o-keyframes blink {    0% { opacity: 1; }    50% { opacity: 1; }    50.01% { opacity: 0; }    100% { opacity: 0; }    }    .blink{    animation: blink .85s linear ease-in;    -webkit-animation: blink .75s ease-out infinite;    -moz-animation: blink .55s ease-out infinite;    -ms-animation: blink .65s ease-out infinite;    -o-animation: blink .45s ease-out infinite;    color: #F00;    font-size:18px;    }    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;div id="header"&gt;    &lt;h2&gt;&lt;hr/&gt;    """    fo.write(htmlText)    fo.close()    fo = open(reportFilePath, "a")  # 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。    fo.write(reportTitle)    htmlText = """&lt;hr/&gt;&lt;/h2&gt;    &lt;/div&gt;    &lt;div id="reportZone"&gt;      &lt;br&gt;    """    fo.write(htmlText)    fo.close()#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#  Purpose - 定义html的尾部div 代码部分#  Notice - 该文件夹和脚本是在同一目录下的#  Date - 2018. 06.16#  Author - Alan.yuan#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def python_WriteHtml_to_File_Part2(reportFilePath):    # reportFilePath 是一个.html文件，这个文件通常由调用脚本生成    fo = open(reportFilePath, 'a')    htmlText = """&lt;/div&gt;    &lt;div id="footer"&gt;    &lt;p&gt;&amp;nbsp Copyright © GDS_TestCenter@163.com. All rights reserved. This consolidation based on our test outputs, and the datum come from Jira and Testlink, it's real and valid. Consolidated here, just want you know more about our Test line, sincerely hope the effort we contributed is indeed to relief you.&lt;/p&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;    """    fo.write(htmlText)    fo.close()#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#  Purpose - 检查文件夹是否存在，如果存在就移除里面所有的文件， 注意是移除里面所有的文件，不是文件夹；如果该文件夹不存在，则创建该文件夹#  Notice - 该文件夹和脚本是在同一目录下的#  Date - 2018. 06.16#  Author - Alan.yuan#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def checkFolder_and_RemoveAllFilesIncluded(folderName):#该函数检当前脚本目录下是否有制定的folder，如果没有则创建该folder；如果有则进入该folder删除里面所有的文件（注意是文件，不是文件夹）    import os, sys    if os.path.exists(os.getcwd() + "\\" + folderName) == True: # folderName - 指的是第一个存储测试报告文件夹 “htmlReport”        for file_Name in os.listdir(os.getcwd() + "\\" + folderName): # os.listdir(os.getcwd() + "\htmlReport") - 该文件夹下包含的文件list            path_File = os.path.join(os.getcwd() + "\\" + folderName, file_Name)            if os.path.isfile(path_File):                os.remove(path_File)    else:        os.makedirs(os.getcwd() + "\\" + folderName)#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#  Purpose - 添加视图到body区，主要是&lt;image&gt; ... &lt;/image&gt; 部分代码#  Notice - 该文件夹和脚本是在同一目录下的#  Date - 2018. 06.16#  Author - Alan.yuan#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def pythonWriteHtml_to_htmlReport(scriptPath, reportFilePath, listVal, listUnit):    htmlTextB = """&lt;iframe src=\""""    htmlTextE = """" marginheight="2px" marginwidth="2px" width="1200" height = "500" frameborder="0"&gt;&lt;/iframe&gt;&lt;br/&gt;"""    i = 0    dirs = os.listdir(scriptPath + "\\1_ResourceforRetro")    for dir in dirs:        if os.path.isfile(os.path.join(scriptPath + "\\1_ResourceforRetro", dir)):            fo = open(reportFilePath, "a")            fo.write("&lt;h3&gt; &gt;&gt;&gt;截止目前，统计有 &lt;span class=\"blink\" &gt;%s &lt;/span&gt;%s  - &lt;/h3&gt;"%(listVal[i], listUnit[i])) # listVal, listUnit元素个数必须和html 文件数相等，否则报溢出错误            # fo.write("&lt;span style=\"border-color: green; border-width: 1px; border-style: solid; border-radius: 1px;\"&gt;")            fo.write(htmlTextB)            fo.write(".\\1_ResourceforRetro\\" + dir)            fo.write(htmlTextE)            fo.close()            i += 1#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#  Purpose - 添加第二个项目的html代码，主要是展示项目名称的&lt;div&gt; ... &lt;/idiv&gt; 部分代码#  Notice - 该文件夹和脚本是在同一目录下的#  Date - 2018. 06.16#  Author - Alan.yuan#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def addSecondProjectReport_Header(reportFilePath, anotherProjectName):    htmlHeard_2B = """&lt;br/&gt;&lt;/div&gt;    &lt;!--Adding new project / task --&gt;    &lt;!--hr style = "height:0px; border:none; border-top:10px solid #55555;"/ --&gt;    &lt;hr style="height:0px;border:none;border-top:10px groove skyblue;" /&gt;    &lt;div class = "anotherProject"&gt;&lt;b&gt;"""    htmlHeard_2E = """&lt;/b&gt;&lt;/div&gt;&lt;div&gt;"""    fo = open(reportFilePath, "a")    fo.write(htmlHeard_2B)    fo.write(anotherProjectName)    fo.write(htmlHeard_2E)    fo.close()#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#  Purpose - 添加第二个项目的html代码，主要是图示的&lt;image&gt; ... &lt;/image&gt; 部分代码#  Notice - 该文件夹和脚本是在同一目录下的#  Date - 2018. 06.16#  Author - Alan.yuan#  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def addSecondProjectReport_Body(scriptPath, reportFilePath):    html2B = """&lt;iframe src=\" """    html2E = """"marginheight="20px" marginwidth="50px" width="1450" height = "550" frameborder="0"&gt;&lt;/iframe&gt;&lt;br/&gt;"""    dirs = os.listdir(scriptPath + "\htmlReport_1")    for dir in dirs:        if os.path.isfile(os.path.join(scriptPath + "\htmlReport_1", dir)):            fo = open(reportFilePath, "a")            fo.write(html2B)            fo.write(".\htmlReport_1\\" + dir)            fo.write(html2E)            fo.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></font></font></font>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python开发 </tag>
            
            <tag> python测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试管理修炼之搭建测试管理平台Testlink</title>
      <link href="/2018/04/17/2018-09-17-ce-shi-guan-li-xiu-lian-zhi-da-jian-ce-shi-guan-li-ping-tai-testlink/"/>
      <url>/2018/04/17/2018-09-17-ce-shi-guan-li-xiu-lian-zhi-da-jian-ce-shi-guan-li-ping-tai-testlink/</url>
      
        <content type="html"><![CDATA[<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation -"></a>Preparation -</h1><ul><li><p>Xampp官方资料 -<br><a href="https://bitnami.com/stack/xampp?utm_source=bitnami&amp;utm_medium=installer&amp;utm_campaign=XAMPP+Installer">https://bitnami.com/stack/xampp?utm_source=bitnami&amp;utm_medium=installer&amp;utm_campaign=XAMPP%2BInstaller</a><br>Xampp ： 建站集成软件包（apache，mysql，php， perl）</p></li><li><p>下载testlink 安装包</p></li><li><p>下载xampp 安装包</p></li></ul><span id="more"></span><h2 id="1-安装指南"><a href="#1-安装指南" class="headerlink" title="1. 安装指南 -"></a>1. 安装指南 -</h2><p>如何安装设置，网上攻略有很多，这里提供一份网友的整理资料，很不错的 ~~<br><a href="https://blog.csdn.net/gjj920318/article/details/51007230">一个有用的参考</a></p><h2 id="2-如何使用Testlink"><a href="#2-如何使用Testlink" class="headerlink" title="2. 如何使用Testlink?"></a>2. 如何使用Testlink?</h2><ol><li>创建测试项目</li><li>创建测试计划</li><li>如有测试需求，可以将测试需求写进来<br>做好这三步，回到Testlink的首页，你就会看到TestLink的全部目录了</li><li>创建测试用例集和测试用例了（根据测试需求、测试用例可以把每一个功能作为一个测试集，然后在每一个测试集中放测试用例）</li><li>把测试计划和测试用例关联起来 （进入TC，click 活动按钮，选择关联测试计划按钮即可关联 ）</li><li>创建测试版本</li><li>执行测试</li><li>如果有重复执行某一个case，可以创建新的版本，将这个case放进来，这样就可以记录每一次测试effort了</li></ol><blockquote><p>测试用例集（测试用例）要与测试计划，测试需求关联起来，并且只有构建了测试版本后，才可以开始测试。只有这样你的测试用例才算是一个完整地测试用例（也就是说一个用例包括了测试计划，需求，测试版本等完整信息），之后就可以分配测试给各个人员了。</p></blockquote><h2 id="3-Testlink中分析结果的图表乱码怎么办？"><a href="#3-Testlink中分析结果的图表乱码怎么办？" class="headerlink" title="3. Testlink中分析结果的图表乱码怎么办？"></a>3. Testlink中分析结果的图表乱码怎么办？</h2><ul><li>如果发现图表显示乱码，可以这么解决</li><li>1、下载&nbsp;tahoma.ttf 字体；</li><li>2、下载好后，我们将其放置到，testlink的安装目录的以下文件夹中：<br> testlink/third_party/pchart/Fonts/<br> 接下来，修改配置文件config.inc.php：<br> 修改<br> $tlCfg-&gt;charts_font_path = TL_ABS_PATH . “third_party/pchart/Fonts/tahoma.ttf”;<br> 为<br> $tlCfg-&gt;charts_font_path = TL_ABS_PATH . “third_party/pchart/Fonts/SIMYOU.ttf”;</li></ul><h2 id="4-TestLink-如何突破文件上传大小限制"><a href="#4-TestLink-如何突破文件上传大小限制" class="headerlink" title="4. TestLink 如何突破文件上传大小限制"></a>4. TestLink 如何突破文件上传大小限制</h2><ul><li>将这两个地方需要进行修改：</li><li>1.&gt; config.inc.php<br> $tlCfg-&gt;repository_max_filesize = 15; //MB<br> $tlCfg-&gt;import_file_max_size_bytes = ‘15409600<br> $tlCfg-&gt;import_max_row = ‘15000000</li></ul><ul><li>2.&gt; php.ini<br> upload_max_filesize=15M<br> post_max_size=15M</li></ul><h2 id="5-Testlink-如何设置邮箱？"><a href="#5-Testlink-如何设置邮箱？" class="headerlink" title="5. Testlink 如何设置邮箱？"></a>5. Testlink 如何设置邮箱？</h2><p>TestLink目录下打开config.inc.php文件修改以下部分，红色背景为填写部分，后面#符号后面为注释，把下面序号后面内容整行直接放到代码中不影响使用（更换真实邮箱地址）。</p><ul><li>（1）$g_smtp_host &nbsp; &nbsp; &nbsp; &nbsp;= ‘smtp.163.com’; &nbsp;# 邮件服务器地址，此处选择163邮箱</li><li>（2）$g_tl_admin_email &nbsp; &nbsp; = ‘<a href="mailto:test@163.com">test@163.com</a>‘; &nbsp;# 问题错误通知邮箱</li><li>（3）$g_from_email &nbsp; &nbsp; &nbsp; &nbsp; = ‘<a href="mailto:test@163.com">test@163.com</a>‘; &nbsp;# 收到收件看到的发送人邮箱地址</li><li>（4）$g_return_path_email &nbsp;= ‘<a href="mailto:test@163.com">test@163.com</a>‘; &nbsp;# 收件人回复的邮箱地址</li><li>（5）$g_phpMailer_method = PHPMAILER_METHOD_SMTP更改为$g_phpMailer_method =SMTP_SEND</li><li>（6）在步骤（5）代码上一行增加define (“SMTP_SEND”,2);</li><li>（7）$g_smtp_username &nbsp; &nbsp;= ‘<a href="mailto:test@163.com">test@163.com</a>‘; &nbsp;# 此处填写你的163信箱地址</li><li>（8）$g_smtp_password &nbsp; &nbsp;= ‘test123546’; &nbsp;# 此处填写163的客户端授权密码，注意一定不是邮箱密码</li><li>（9）$g_smtp_connection_mode = ‘ssl’;</li><li>（10）$g_smtp_port = 994; &nbsp; &nbsp;<br>我申请了一个<a href="mailto:XXX_testcenter@163.com">XXX_testcenter@163.com</a>的邮箱 (password:xxxxxx) / 授权码是：嘻嘻嘻嘻嘻<br>保存退出，设置完毕，可使用TestLink密码找回功能尝试是否成功。</li></ul><h2 id="Testlink使用小结"><a href="#Testlink使用小结" class="headerlink" title="Testlink使用小结"></a>Testlink使用小结</h2><ul><li><p>使用testlink要结合实际测试流程，这样使用起来才能得心应手，通常我们可以按照如下步骤来使用该系统：</p><blockquote><p><font color="#dd00dd" face="黑体">测试项目-&gt; 测试计划 （使其活动）-&gt; 测试需求 -&gt; 测试用例 -&gt; 测试版本 -&gt; 测试分配 -&gt; 测试执行 -&gt; 测试统计</font></p><font color="#dd00dd" face="黑体"></font></blockquote><font color="#dd00dd" face="黑体"></font></li><font color="#dd00dd" face="黑体"></font></ul><font color="#dd00dd" face="黑体"><ul><li><p>要执行测试必须要有测试计划和测试版本（也就是计划和测试构建）而计划必须和TC关联的，因此当执行某个TC时，一定是某个计划的某个版本（构建）下的某个TC；测试计划关联测试用例和测试构建（版本）；另外，如果有测试平台的话，在将测试用例和测试计划关联时也要将测试平台关联进去。这样在执行测试时就可以选择在某个平台下的测试用例了。（设置好后，在执行测试时，在右边的设置/Filter栏位可以选择是执行哪个平台下的测试用例了。）</p></li><li><p>另外，测试用例和测试需求理论上也需要关联，同测试用例类似，先建立一个“需求规格”，然后在需求规格下面新建具体需求，然后再将需求关联到具体的TC，如果只有需求规格，下面没有具体需求，那么无法将TC和需求关联起来。想想也是这个道理，每具体需求关联什么呀？</p></li><li><p>在测试结果中，可以在“测试用例分派概览”和“测试结果矩阵”报表中查看测试执行小图标来查看该用例执行的次数和每次的工时。由此可以统计出某一计划下所有执行的完整工时。其他报表点击用户进入用户视图，也可以找到执行图标来查看，但没有这两个报表来得直接；其他视图展示出来的工时，通常只是最近执行的工时，不可用这此工时来代替完整工时统计。</p></li></ul></font>]]></content>
      
      
      <categories>
          
          <category> 测试管理 </category>
          
          <category> testlink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试管理 </tag>
            
            <tag> testlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python在Excel中的应用</title>
      <link href="/2017/09/22/2018-09-22-python-zai-excel-zhong-de-ying-yong/"/>
      <url>/2017/09/22/2018-09-22-python-zai-excel-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p>这是之前做的一个python在excel中使用的例子，个人感觉还是蛮有意思的，今天拿出来分享给大家，其中也许有你感兴趣的地方。</p><ol><li>代码执行的结果如下 -<br><a href="/medias/Excution_Result.xlsx">查看结果</a></li></ol><span id="more"></span><ol start="2"><li>代码实现如下 -<pre class="line-numbers language-none"><code class="language-none">from selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionimport time, osfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.wait import WebDriverWaitfrom Python_TestReport_Excel_Template import *from win32com.client import Dispatch, constantsimport win32com.clientimport os, timedef Preprocess_Environment_One_to_Five():    # return 'startTime' - Don't change this return variable name because it will be used in report format function.    os.system('taskkill /fi "imagename eq exce*" /f')    os.system('taskkill /IM IEDriverSe* /f')    os.system('taskkill /fi "imagename eq iexplo*" /f')    initialTime = datetime.datetime.now()    return initialTimestartTime = Preprocess_Environment_One_to_Five()# Get current script path and folderdef CollectInfo_for_TestReport():    # Get parameters of script path and report path    getRootFolder = os.path.abspath(".") # get whole folder path which saved all current scripts.    # get current Date and script Name    getCurrentDate = time.strftime("%Y-%m-%d", time.localtime())    suffixScriptName = os.path.basename(__file__)    pureScriptName = suffixScriptName.split('.', 1)[0]    reportPath = os.path.join(getRootFolder, "Test_Reports", getCurrentDate, pureScriptName)    return pureScriptName, reportPathpureScriptName, reportPath = CollectInfo_for_TestReport() # 这两个变量名不要更改名字，因为后面需要这两个变量作为参数值，因为名称完全一样，所以这里的变量名不要随意更改。def Create_Report_and_Initialize_Headers(reportPath):    # Create Report Path and report file and rename the default sheet name to Runtime_1    reportFile = os.path.join(reportPath, "Excution_Result.xlsx")    headersList = ('No', 'Checkpoints', 'Expectation Result', 'Real Result', 'Final Status', 'Screen Shot', 'Other Reference') # Header 请按此顺序定义column, 后续程序根据此column来展开脚本    print "&gt;&gt;&gt; Test report will be created and located here - ", reportFile    if os.path.exists(reportPath): # 这里的参数不能为具体的文件名路径，只能是Folder的path        pass        print "&gt;&gt;&gt; Report path was created already, please check the test report file and see if it also be created"    else:        os.makedirs(reportPath)  # 一次性创建多级目录，而mkdir一次只能创建一级目录, makedirs 和 mkdir只能创建文件夹，并不能穿件文件本身; 另外，makedirs不能覆盖存在的路径。        # fo = open(reportFile, 'w+')        # fo.close()  # 创建的Excel.xlsx文件没法打开，由于格式不兼容的问题    if os.path.exists(reportFile):        print "&gt;&gt;&gt; Test report already created and here need to do is to add one more new sheet and initialized "        xlApp = Dispatch("Excel.Application")  # 连接 excel 对象        xlOpenWorkBook = xlApp.Workbooks.Open(reportFile)        sheetCount = xlOpenWorkBook.Worksheets.Count        addedSheetName = "Runtime_" + str(sheetCount + 1)        xlApp.Worksheets.Add().Name = addedSheetName        for i in range(0, len(headersList)):            xlOpenWorkBook.Worksheets(addedSheetName).Cells(1, i+1).value = headersList[i]        xlOpenWorkBook.Save() # 此处用Save()保存已打开的excel文件，无论之前的excel是否开启，都可以执行代码；不要用SaveAs(reportFile)会出现保存的文件已开启的提示框，而Python对windows下的excel提示框，不好操作        xlApp.Quit()    else:        xlApp = Dispatch("Excel.Application")  # 连接 excel 对象        xlBook = xlApp.Workbooks.Add()  # 新建一个excel文件        xlBook.Worksheets[0].name = "Runtime_1"  # 默认情况下只创建包含一个名为 ‘sheet1’ 的表单        for i in range(0, len(headersList)):            xlBook.Worksheets[0].Cells(1, i+1).value = headersList[i] # initialize header base on the headerlist parameter        xlBook.SaveAs(reportFile)        xlApp.Quit()        print "&gt;&gt;&gt; Test Report was just created and initializated headers"    return reportFile    # define Report Headers -# headerList = ('No', 'Checkpoints', 'Expectation Result', 'Real Result', 'Final Status', 'Screen Shot', 'Other Reference')# reportFile = Create_Report_and_Initialize_Headers(reportPath, *headerList)reportFile = Create_Report_and_Initialize_Headers(reportPath)class Add_Checkpoints:    # os.system('taskkill /fi "imagename eq exce*" /f')    def byPassed(self, reportFile, checkPointStatement):        xlApp = Dispatch("Excel.Application")        xlOpenWorkBook = xlApp.Workbooks.Open(reportFile)        sheetCount = xlOpenWorkBook.Worksheets.Count; objSheetName = "Runtime_" + str(sheetCount) #获得sheet name 主要是为了从sheet名称上来打开指定的sheet，当然也可以用sheets[0]来表示，因为在脚本中创建的sheet都是位于第一个sheet的位置        rowCount = xlOpenWorkBook.Worksheets(objSheetName).UsedRange.Rows.Count        objSheet = xlOpenWorkBook.Worksheets(objSheetName) # Notice 下面的写法同样有效。        # objSheet = xlApp.Worksheets(objSheetName)        objSheet.Cells(rowCount + 1, 1).Value = rowCount        objSheet.Cells(rowCount + 1, 2).Value = checkPointStatement        objSheet.Cells(rowCount + 1, 3).Value = "The checkpoint of '" + checkPointStatement + "' should be able to go smoothly with this pre-condition"        objSheet.Cells(rowCount + 1, 4).Value = "Yeah ... ! Scripts really detected this checkpoint'" + checkPointStatement + "' at the specified condition"        objSheet.Cells(rowCount + 1, 5).Value = "Pass"        xlOpenWorkBook.Save() # Notice - Save 和Save()的区别，一个是单纯的宏命令动作，一个是方法，方法里面包含了对save这个动作的后续处理。所以这里如果只用Save则会弹出保存对话框，不如Save()方便直接。        xlApp.Quit()    def byFailure(self, reportFile, checkPointStatement):        # os.system("taskkill /F /IM Exce*")        xlApp = Dispatch("Excel.Application")        xlOpenWorkBook = xlApp.Workbooks.Open(reportFile)        sheetCount = xlOpenWorkBook.Worksheets.Count; objSheetName = "Runtime_" + str(sheetCount)  # 获得sheet name 主要是为了从sheet名称上来打开指定的sheet，当然也可以用sheets[0]来表示，因为在脚本中创建的sheet都是位于第一个sheet的位置        rowCount = xlOpenWorkBook.Worksheets(objSheetName).UsedRange.Rows.Count        objSheet = xlApp.Worksheets(objSheetName)        objSheet.Cells(rowCount + 1, 1).Value = rowCount        objSheet.Cells(rowCount + 1, 2).Value = checkPointStatement        objSheet.Cells(rowCount + 1, 3).value = "The checkpoint of '" + checkPointStatement + "' should be able to go smoothly with this pre-condition" # please use plus symbol instead comma to combine varaible and string here        objSheet.Cells(rowCount + 1, 4).Value = "Unfortunately ... ! Scripts didn't detect this checkpoint'"+ checkPointStatement +"' at the specified conditions" # 连接checkPointStatement变量，不能用comma,只能用plus/ + 号        objSheet.Cells(rowCount + 1, 5).Value = "Failure"        xlOpenWorkBook.Save()        xlApp.Quit()newClass = Add_Checkpoints()  # 必须要实例化类才能使用，这是常识。# if 'xiaole' in "alan love xiaole":#     newAClass.byPassed("Check string - 'alan' and see if it's existing in 'alan love xiaole' string")# else:#     newAClass.byFailure("Check string - 'alan' and see if it's existing in 'alan love xiaole' string")## time.sleep(15)for i in range(0, 1):    if u"张寒冰" in u"这段文字中包含张寒冰三个字吗？":        newClass.byPassed(reportFile, u"search '张寒冰' and see if it's searched in the gaven string")    else:        newClass.byFailure(reportFile, u"search '张寒冰' and see if it's searched in the gaven string")    if u"张寒冰" in u"这段文字中能找出张汉滨吗？":        newClass.byPassed(reportFile, u"search '张寒冰' and see if it's searched in the gaven string")    else:        newClass.byFailure(reportFile, u"search '张寒冰' and see if it's searched in the gaven string")    if "morgan" in "www.morgan.com.\mainpage.index\Finace.us.123.pageo":        newClass.byPassed(reportFile, "Check Mogstandley and see if it's in this string 'www.morgan.com'");    else:        newClass.byFailure(reportFile, "Check Mogstandley and see if it's in this string 'www.morgan.com'")    if "Shanghai Financial" in "List all the records which search by Sublege for Baidu, and Tencent":        newClass.byPassed(reportFile, "Check the string of 'subledge' and see if it will be show at the specified page which searched by definited for Baidu and Tencent")    else:        newClass.byFailure(reportFile, "Check the string of 'subledge' and see if it will be show at the specified page which searched by definited for Baidu and Tencent")    if "Shanghai" in "www.morgan.com.mainpage.index.Shanghai Finanial Center":        newClass.byPassed(reportFile, "Check Mogstandley and see if it's in this string 'www.morgan.com.\mainpage.index\Finace.us.233.pageContext'")    else:        newClass.byFailure(reportFile, "Check Mogstandley and see if it's in this string 'www.morgan.com.\mainpage.index\Finace.us.233.pageContext'")    if "Xiaole" in "www.morgan.com\second1-2-3\content.list-us.sgn-Xiaole":        newClass.byPassed(reportFile, "Check the string of 'Xiaole' and see if it will be show at the specified page content 'www.morgan.com\second1-2-3\content.list-us.sgn-Xiaole'")    else:        newClass.byFailure(reportFile, "Check the string of 'Xiaole' and see if it will be show at the specified page content 'www.morgan.com\second1-2-3\content.list-us.sgn-Xiaole'")    if "LuckyLee" in u"请将每天的作业按时做完，然后也完成我的家庭作业和课外练习题，睡觉前送我检查并签字，切记！send to LucyLee":        newClass.byPassed(reportFile, u"检查乐乐的作业情况是否按时完成！并记得每天签字 - Yuan, Jun-tao")    else:        newClass.byFailure(reportFile, u"检查乐乐的作业情况是否按时完成！并记得每天签字 - Yuan, Jun-tao")# openedWorkBook = xlApp.Workbooks.Open("C:\\temp\\alan123.xlsx")# print openedWorkBook.Worksheets.Count# print openedWorkBook.Worksheets[0].name; openedWorkBook.Worksheets.Item(1).name # 两种写法均可获得sheet name# print openedWorkBook.Worksheets[0].UsedRange.Rows.Count# print openedWorkBook.Worksheets[0].UsedRange.Columns.Count#`def Format_Report(reportFile, scriptAuthor, startTime, getPureScriptName = pureScriptName):    if os.path.exists(reportFile):        # Step One - Create Excel.Application Object and Open an existing file and enter the specified sheet        xlApp = Dispatch("Excel.Application")        xlOpenWorkBook = xlApp.Workbooks.Open(reportFile)        sheetCount = xlOpenWorkBook.Worksheets.Count;        objSheetName = "Runtime_" + str(sheetCount)  # 获得sheet name 主要是为了从sheet名称上来打开指定的sheet，当然也可以用sheets[0]来表示，因为在脚本中创建的sheet都是位于第一个sheet的位置        xlOpenSheet = xlOpenWorkBook.Worksheets(objSheetName)        #Step Two - Format specified sheet Font.Size and Font Bold        xlOpenSheet.UsedRange.Font.Name = "Gill Sans MT"        xlOpenSheet.UsedRange.Font.Size = 10        xlOpenSheet.UsedRange.Rows(1).Font.Size = 12 # Rows(1) 和 Row[1] 表示的意义不一样，前者代表第一行，后者表示第二行。这就是下标使用的作用        xlOpenSheet.UsedRange.Rows(1).Font.Bold = True # Notice this expression and it's equal the usage below in Bold and Italic        # Add border and add two more top row for Report Title        xlOpenSheet.UsedRange.Borders.LineStyle = 1        # xlOpenSheet.UsedRange.Rows(1).Borders.LineStyle = -4119        xlOpenSheet.Rows[0].Insert()        xlOpenSheet.Rows[0].RowHeight = 5 # 设置行高; ColumnWidth 用于设置列宽        xlOpenSheet.Rows[0].Insert()        xlOpenSheet.Rows[0].RowHeight = 30        xlOpenSheet.Range("A1:G1").Borders(4).LineStyle = 1        xlOpenSheet.Range("A1:G1").Borders(4).Weight = 3 # may be 4, 3, 1 not others        xlOpenSheet.Range("A1:G1").Merge() # merge cells for report title text        xlOpenSheet.Cells(1, 1).Value = "Execution Result for Scripts - " + pureScriptName # define the report title        # xlOpenSheet.Range("A1").Font.ColorIndex = 5 # or 41 for setting  blue and light blue value        xlOpenSheet.Cells(1, 1).Font.Name = "Gill Sans MT"; xlOpenSheet.Cells(1, 1).Font.Size = 15; xlOpenSheet.Cells(1, 1).Font.Bold = True        # How to implement AutoFit?        # xlOpenSheet.UsedRange.Columns.AutoFit()        xlOpenSheet.UsedRange.EntireColumn.AutoFit()        xlOpenSheet.UsedRange.HorizontalAlignment = 2 # maybe these value - Alignment, 1=auto | Alignment, 2=left | Alignment, 3=centre |Alignment, 4=right | |        xlOpenSheet.UsedRange.VerticalAlignment = 2 # may be these initialization - Alignment, 1=top | Alignment, 2=middle | Alignment, 3=bottom |        # Set report tile alignment and make it align on bottom        xlOpenSheet.UsedRange.Rows(1).VerticalAlignment = 3        # Format Result Color and make the failure record highlighted by Red font and then statistic the checkpoints result        rowsCount = xlOpenSheet.UsedRange.Rows.Count; passQty = 0; failQty = 0        for i in range(4, rowsCount + 1):            if "Pass" == xlOpenSheet.Cells(i, "E").value: # Notice here - .value is quitely equal .Value                passQty += 1                pass            else:                print "&gt;&gt;&gt; A failure checkpoint found"                xlOpenSheet.UsedRange.Rows(i).Font.ColorIndex = 46 ; xlOpenSheet.UsedRange.Rows(i).Font.FontStyle = "Italic"; xlOpenSheet.UsedRange.Rows(i).Font.Bold = True  # ColorIndex value can refer to the "https://zhidao.baidu.com/question/90240687.html".                xlOpenSheet.UsedRange.Cells(i, "E").Font.ColorIndex = 6 # set font to red                # xlOpenSheet.UsedRange.Rows(i).Interior.ColorIndex = 3 #  set the selected block back graound color to red                xlOpenSheet.UsedRange.Cells(i, "E").Interior.ColorIndex = 3 # set the cell back ground color not for Font color                failQty += 1        # 增加最左边一列，以利排版美观        xlOpenSheet.Range("A:A").Insert() # Notice - this expression is actually equal with aove one on Insert()        xlOpenSheet.Range("A1:A" + str(rowsCount + 7)).Borders(2).LineStyle = 1; xlOpenSheet.Range("A1:A" + str(rowsCount + 13)).Borders(2).Weight = 4 # 格式化首列的最右边的实线边框        # xlOpenSheet.Cells(1, 1).Border(3).LineStyle = 1; xlOpenSheet.Cells(1, 1).Borders(3).Weight = 4; xlOpenSheet.Columns(1).ColumnWidth = 12 # Cells对象后面没有Borders属性，只能用Range来调用Border属性        xlOpenSheet.Range("A1").Borders(4).LineStyle = 1; xlOpenSheet.Range("A1:A1").Borders(4).Weight = 3; xlOpenSheet.Columns("A").ColumnWidth = 4 # 格式化单元格A1的宽度和下划线, 注意这里Range("A1")不能写成Cells("A1"), 否则报错        # 去掉视图的网格线以及标题栏和标尺等属性        xlApp.ActiveWindow.DisplayGridlines = False        xlApp.ActiveWindow.DisplayHeadings = False        xlApp.ActiveWindow.DisplayFormulas = False        xlApp.ActiveWindow.DisplayWhitespace = False        xlApp.ActiveWindow.DisplayRuler = False        # Extract and calculate Key words information        xlOpenSheet.Cells(rowsCount + 3, 2).Value = "Key Information Extract -"; xlOpenSheet.Cells(rowsCount + 3, 2).Font.Name = "Gill Sans MT"; xlOpenSheet.Cells(rowsCount + 3, 2).Font.FontStyle = "Bold" ; xlOpenSheet.Range("B" + str(rowsCount + 3) + ":C" + str(rowsCount + 3)).Borders(4).LineStyle = 1 # 注意此处Bold的设置和前面同样效果的设置区别        projectName = reportFile.split("\Test_Reports")[0].split("\\")[len(reportFile.split("\Test_Reports")[0].split("\\")) - 1]        currentTime = datetime.datetime.now(); differ = (currentTime - startTime).seconds; h = differ / 3600; m = (differ % 3600) / 60; s = (differ % 3600) % 60 # the calculation difference between operate / and //, they would get the same value when the calculate under the all intgers, or difference        durationTime = str(h)+':'+str(m)+':'+str(s)        # Merge Rows and Definition the key words informations -        xlOpenSheet.Range("B" + str(rowsCount + 4) + ":H" +  str(rowsCount + 12)).Merge()        xlOpenSheet.Cells(rowsCount + 4, "B").Value = " Script Name: " + getPureScriptName + "     \n Project Name: " + projectName + "        \n Duration (Hr:Min:Sec) - " + durationTime + "       \n Passed Checkpoints: " + str(passQty) + "          \n Failed Checkpoints: " + str(failQty) + "        \n Automated Architecture Author: Alan.Yuan        \n Script Executor/Designer: " + scriptAuthor        xlOpenSheet.UsedRange.Rows(rowsCount + 4).Font.Name = "Gill Sans MT"; xlOpenSheet.UsedRange.Rows(rowsCount + 4).Font.Size = 10 ; #xlOpenSheet.Range("B" + str(rowsCount + 4) + ":H" +  str(rowsCount + 12)).Font.FontStyle = "Italic";        # xlOpenSheet.UsedRange.Rows(rowsCount + 4).VerticalAlignment = 1 # Notice - Range() 和 UsedRange.Rows()的用法，这里不可用Rows()取代UsedRange.Rows()，否则报错        # rowCount = xlOpenWorkBook.Worksheets(objSheetName).UsedRange.Rows.Count        xlOpenWorkBook.Save()        print "So far, there are", xlOpenSheet.UsedRange.Rows.Count, "rows are available" # comma 连接的是任何数据类型，并且会自动加空格；plus连接的是同类型数据，不会自动加空格，这既是，和 + 连接符的区别        print "So far, there are", xlOpenSheet.UsedRange.Columns.Count, "Columns are available"        xlApp.Quit()# scriptAuthor=u"Lello_Lucky"Format_Report(reportFile, "Lello_Yuan", startTime)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> python自动化 </category>
          
          <category> excel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自动化 </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试管理修炼之如何成为一名优秀的测试总监</title>
      <link href="/2017/06/19/2017-06-19-ce-shi-guan-li-xiu-lian-zhi-ru-he-cheng-wei-yi-ming-you-xiu-de-ce-shi-zong-jian/"/>
      <url>/2017/06/19/2017-06-19-ce-shi-guan-li-xiu-lian-zhi-ru-he-cheng-wei-yi-ming-you-xiu-de-ce-shi-zong-jian/</url>
      
        <content type="html"><![CDATA[<p>俗话说得好，不经历风雨怎么见彩虹，不被坑的领导不是真正的领导。测试工作是一门跨学科的工作，想成为一名优秀的测试管理者，除了具备跨学科的综合技能外，在制定工作流程和规章制度中一定要遵循可实施，可监督，可统计，可归纳等基本要素，如何做到这一点呢，我认为不防从如下方面多多思考和历练。</p><span id="more"></span><p>首先测试的类别繁多，平常所说的功能测试，性能测试，压力测试，冒烟测试，回归测试，平台测试（SDK、Web，GM工具等等）就琳琅满目，不胜枚举。作为一个测试管理者，可根据团队实际情况（如人员多少，团队整体技术力量，测试环境等），合理的划分测试类别和内容。把功能和关联性强的接口日志等放在测试组中测试，把关联性较弱的如性能，平台兼容性，SDK，单元测试等放在平台组中去测试。这样可以充分发挥团队的效率。一旦测试任务和测试资源确定后，可以通过如下的步骤来具体实施。</p><p>这里我把质量管理的工作拆分为如下九个过程来具体展开 -</p><ul><li>软件质量管理的九个方面<br><img src="/medias/testArchitecture.png" alt="Quality Architecture"></li></ul><h6 id="1-需求管理过程"><a href="#1-需求管理过程" class="headerlink" title="1. 需求管理过程 -"></a>1. 需求管理过程 -</h6><pre class="line-numbers language-none"><code class="language-none">我认为测试人员至少要关注这些方面 ○ 评估需求的合理性 - 不是100%的接受需求描述，哪些不合理的需求，哪些值得优化的地方，需要及时的指出 ○ 思考测试难度和测试周期 - 梳理需求时要尽量考虑每个功能点的难易度和评估所需时间，对于那些不能测试，或者测试难度很大的地方要及时提出，并和相关开发人员沟通解决方案，尽量做到全面，准确的评估。有利于后续的计划安排。 ○ 思考关联度 - 是不是全新的功能需求，是否与已有的功能有关联，是否需要测试性关联的功能点。这也是在需求管理过程中值得关注的地方。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-计划管理过程"><a href="#2-计划管理过程" class="headerlink" title="2. 计划管理过程"></a>2. 计划管理过程</h6><pre class="line-numbers language-none"><code class="language-none">这个过程中核心就是时间，每个环节的时间预估越准确，则项目的可控性越高，反之，则会导致各种不可预估的延期。作为测试质量管理者，可从以下方面来考量计划的制定<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="3-任务分配过程"><a href="#3-任务分配过程" class="headerlink" title="3. 任务分配过程"></a>3. 任务分配过程</h6><p>从这几方面来考虑<br> <img src="/medias/taskAsssign.png" alt="Task Assingment"></p><h6 id="4-执行管理过程"><a href="#4-执行管理过程" class="headerlink" title="4. 执行管理过程"></a>4. 执行管理过程</h6><pre class="line-numbers language-none"><code class="language-none">关注和监督执行情况，了解动态信息，发现可能导致结果达不到的苗头要及时作出调整，或增加人手，或调整任务，或修改预期方案等等。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="5-反馈管理过程"><a href="#5-反馈管理过程" class="headerlink" title="5. 反馈管理过程"></a>5. 反馈管理过程</h6><p>任务信息孤岛的出现会给项目带来潜在的风险，所以不要关起门来做测试，要及时的沟通，协调，不仅要知道自己在干什么，也要知道别人在干什么，也要让别人知道你在干什么。<br> <img src="/medias/fackbackManagement.png" alt="feedback managemnet"></p><h6 id="6-bug管理过程"><a href="#6-bug管理过程" class="headerlink" title="6. bug管理过程"></a>6. bug管理过程</h6><p>Bug管理最常见，也最容易被大家忽视。在这个过程中，我们需要关注八个方面，见下图：<br> <img src="/medias/bugManagement.png" alt="bug Management"></p><p>其中bug数据分析，可以帮助我们清楚地了解，哪些模块，哪些开发人员容易出错，推进TDD模式，也许可以从此展开</p><h6 id="7-版本管理过程"><a href="#7-版本管理过程" class="headerlink" title="7. 版本管理过程"></a>7. 版本管理过程</h6><pre class="line-numbers language-none"><code class="language-none">○ 版本内容 -该进版本的内容必须进全，不该进版本的内容必须不进。这句看似废话的描述，实则是各种血泪史的控诉。版本中无论是少内容还是多内容，都会导致bug的出现。发版本前，多花一些时间，检查和控制好版本内容，则完全可以避免这一类问题的出现，做到防患于未然远比出了问题再修改要好的多。另一点则是，任何内容的提交都需要经过测试，这条也是蹚了无数的雷才形成的流程。任何自认为代码没问题就提交而未经过测试的，往往是频繁出bug的地方。○ 版本时间 - 为什么版本时间这么重要？晚一天发布不行吗？真实的答案是不行。任何跨天的延期发布都可能导致游戏内众多的活动内容调整，官网内容调整，更不用说昂贵的广告费用打了水漂。所以版本时间一定要控制好，尽量提前预估好时间，留出充足的时间来准备发布。○ 其他 - 除了上述2点需要注意的，版本管理还需要注意兼容、版本纪录和版本发布后的线上监控等琐碎问题。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="8-文档管理过程"><a href="#8-文档管理过程" class="headerlink" title="8. 文档管理过程"></a>8. 文档管理过程</h6><p>文档管理重要程度看似鸡肋，而往往则是这个鸡肋能关键时刻救你一命。一个项目周期越长，如果没有详细的文档纪录，还有项目人员的变动，可能到项目后期都没有一个人能清楚某些规则。对于测试也是一样，需要做哪些文档管理呢？见下图：<br> <img src="/medias/documentManagement.png" alt="Document Mnanagement"></p><pre class="line-numbers language-none"><code class="language-none">还是那句话，传承做不好的项目不是好项目。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="9-部门沟通协调管理过程"><a href="#9-部门沟通协调管理过程" class="headerlink" title="9. 部门沟通协调管理过程"></a>9. 部门沟通协调管理过程</h6><pre><code>在现在项目过程中，协调部门间的资源越发重要，这基于两点现实：○ 任何个体都无法保证项目质量。○ 资源具有稀缺性，需要协调一切可利用的资源为己所用。怎么做？一句话，沟通，不断沟通，玩命沟通。踩过了无数的坑，才能明白做好项目的质量保证工作并非易事。趟了无数的雷，才能将一条条血泪总结成经验流程。</code></pre><p>参考资料 -<br><a href="http://www.51testing.com/html/12/n-3702192812.html">http://www.51testing.com/html/12/n-3702192812.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试管理 </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试中必须了解的Linux</title>
      <link href="/2016/11/16/2018-10-31-ce-shi-zhong-bi-xu-liao-jie-de-linux/"/>
      <url>/2016/11/16/2018-10-31-ce-shi-zhong-bi-xu-liao-jie-de-linux/</url>
      
        <content type="html"><![CDATA[<p>测试是一门关联性强，接触面广，同时又是专业性很强的学科门类，在这个领域发展需要学习和掌握的内容很多，在众多的知识技能里，Linux绝对是你不可或缺的一部分，了解和熟练掌握Linux，不仅能提升你的工作效率还能帮你get到很多的技能，极大地提升了测试竞争力。下面一起来看看哪些Linux技能是测试角色必须要熟悉和掌握的 -</p><span id="more"></span><h5 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h5><p>Linux常用文件和目录（即文件夹）说明 -</p><ol><li>/ : 是根目录（顶级目录）</li><li>bin ：存放二进制可执行文件</li><li>sbin ：root才能访问的二进制可执行文件</li><li>usr : 存放共享的系统资源，类似于Windows下的program files</li><li>lib : 类库</li><li>mnt ：默认挂载光驱和软驱的目录</li><li>home : 存放普通用户的相关文件</li><li>root : 顾名思义，存放root用户的相关文件</li><li>etc : 存放配置的相关文件</li><li>var : 存放经常变化的文件，如网络连接的socket文件等</li></ol><p><strong>1. Linux常用命令</strong><br><b>1.1 文件目录相关的 -</b></p><b><ul><li><p><font color="red">cd 访问目录，改变目录</font><br>ex. cd /opt/alan/image.jpg (绝对路径)； cd alan(当前目录/opt下, 相对路径)</p></li><li><p><font color="red">pwd 查看当前目录</font><br>ex. [root@www ~]# pwd [-P]</p></li><li><p><font color="red">mkdir 创建新目录</font><br>ex. mkdir [-mp] 目录名称 (-m：配置文件的权限，直接配置，不需要看默认权限的脸色；-p：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！)</p></li><li><p><font color="red">rmdir 删除空目录</font><br>ex. rmdir [-p] 目录名称 (-p: 连同上一级空的目录也一起删除)</p></li><li><p><font color="red">cp 复制文件或目录</font><br>ex. [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)<br>[root@www ~]# cp [options] source1 source2 source3 …. directory</p></li><li><p><font color="red">rm 移除文件或目录</font></p></li><li><p><font color="red">mv 移动文件与目录，或修改文件名称</font></p></li><li><p><font color="red">cat 查看文件内容</font><br>ex. cat [-AbEnTv] (AbEnTv 是相关参数，详细用法可以参考本文后面的参考文档)</p></li><li><p><font color="red">tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</font><br>ex. [root@www ~]# tac /etc/issue</p></li><li><p><font color="red">nl 显示行号</font><br>ex. nl [-bnw] 文件</p></li><li><p><font color="red">more 一页一页翻动</font></p></li><li><p><font color="red">less 一页一页翻动</font></p></li><li><p><font color="red">head 输出文件前几行内容</font></p></li><li><p><font color="red">tail 输出文件后几行内容</font></p></li></ul><p><b>1.2 用户账号管理相关的 -</b></p><b><ul><li><p>添加新的用户账号使用useradd命令，其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">useradd 选项 用户名# useradd –d /usr/sam -m sam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除账号, 删除一个已有的用户账号使用userdel命令，其格式如下：</p><pre class="line-numbers language-none"><code class="language-none">usermod 选项 用户名# userdel -r sam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改账号， 修改已有用户的信息使用usermod命令，其格式如下：</p><pre class="line-numbers language-none"><code class="language-none">usermod 选项 用户名# usermod -s /bin/ksh -d /home/z –g developer sam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>用户口令管理， 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p><pre class="line-numbers language-none"><code class="language-none">passwd 选项 用户名$ passwdOld password:******New password:*******Re-enter new password:*******<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>另外，用户组的管理也有一组相似的Linux处理命令，详细用法也请参考文章尾部的参考链接，这里不一一赘述了。</li></ul><p><b><a href="http://www.runoob.com/linux/linux-filesystem.html">参考链接</a></b></p><b></b></b></b>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Unix </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Unix </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Markdown Syntax</title>
      <link href="/2016/10/15/2018-10-15-basic-markdown-syntax/"/>
      <url>/2016/10/15/2018-10-15-basic-markdown-syntax/</url>
      
        <content type="html"><![CDATA[<h5 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h5><p>markdown是一个纯文本的标识语言，可以用它来生成一定格式的文本文件，Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然Markdown 语法的目标是就是要成为一种适用于网络的书写语言。</p><h5 id="常用的Markdown语法介绍"><a href="#常用的Markdown语法介绍" class="headerlink" title="常用的Markdown语法介绍"></a>常用的Markdown语法介绍</h5><p><strong><font color="red">标题</font></strong></p><ol><li>支持两种标题语法，类Setext和类atx -<br>这是类Setext的表示形式（= 和 -）<h1 id="东方闪电"><a href="#东方闪电" class="headerlink" title="东方闪电"></a>东方闪电</h1>东方闪电</li></ol><p>–  </p><span id="more"></span><ol start="2"><li>这是atx的表示形式（#一共有6级）<h1 id="东方闪电-1"><a href="#东方闪电-1" class="headerlink" title="东方闪电"></a>东方闪电</h1><h2 id="东方闪电-2"><a href="#东方闪电-2" class="headerlink" title="东方闪电"></a>东方闪电</h2><h3 id="东方闪电-3"><a href="#东方闪电-3" class="headerlink" title="东方闪电"></a>东方闪电</h3><h4 id="东方闪电-4"><a href="#东方闪电-4" class="headerlink" title="东方闪电"></a>东方闪电</h4><h5 id="东方闪电-5"><a href="#东方闪电-5" class="headerlink" title="东方闪电"></a>东方闪电</h5><h6 id="东方闪电-6"><a href="#东方闪电-6" class="headerlink" title="东方闪电"></a>东方闪电</h6></li></ol><p><strong><font color="red">区块（Blockquote）引用</font></strong><br>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt;</p><pre class="line-numbers language-none"><code class="language-none">&gt;这部分内容为区块引用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这部分内容为区块引用</p></blockquote><p><strong><font color="red">列表</font></strong><br>Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记；有序列表则使用数字接着一个英文句点表示。<br>无序列表 -</p><pre class="line-numbers language-none"><code class="language-none">*  Red*  Green*  Blue等同于+  Red+  Green+  Blue也等同于-  Red-  Green-  Blue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示效果为 -</p><ul><li>  Red</li><li>  Green</li><li>  Blue</li></ul><p>有序列表 -</p><pre class="line-numbers language-none"><code class="language-none">1. red2. Green3. Blue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>显示效果为 -</p><ol><li>red</li><li>Green</li><li>Blue</li></ol><p><strong><font color="red">分隔线</font></strong><br>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线</p><pre class="line-numbers language-none"><code class="language-none">***** * *-----______<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如下效果 -</p><hr><hr><hr><p><strong><font color="red">文本样式</font></strong></p><pre class="line-numbers language-none"><code class="language-none">** 加粗 ***斜体*~~删除线~~` 底纹 `<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下 -</p><p><strong>加粗</strong></p><p><em>斜体</em></p><p><del>删除线</del></p><p><code>底纹</code></p><p><strong><font color="red">图片与链接</font></strong><br>如果只是简单的插入图片和连接，那么非常简单。两者仅仅是一个 「 ! 」 的区别。</p><pre class="line-numbers language-none"><code class="language-none">图片![图片描述](链接的地址)快捷键：control + shift + I** 链接 **[文本内容](链接的地址)快捷键：control + shift + L<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下 -  </p><p><img src="/medias/1126559.png" alt="这是图片链接"><br><a href="https://www.lello.top/">文本链接</a></p><p><strong><font color="red">代码框</font></strong><br>位于```和```之间的包裹部分为代码框的内容表述<br>如 -</p><pre class="line-numbers language-none"><code class="language-none">这里属于代码框表述的部分<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><font color="red">表格</font></strong><br>这部分有点复杂，关键是分隔符的使用，下面三种情况都能表示类似的效果，请参考 -<br><img src="/medias/markdowntable.png" alt="markdowntable.png"></p><p><strong><font color="red">注释</font></strong><br>  注释用来标注用户自定义信息，和html语法类似，这部分内容只给用户编辑看的，发布后没有实际显示效果<br> </p><pre class="line-numbers language-none"><code class="language-none">&lt;!--我是注释，标注只给我自己看的内容--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p><strong><font color="red">脚注</font></strong><br>  脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。  </p><p>  点击这里看看，我有注释哦！[^1]<br>  [^1]: 这是我的注释 (这个我貌似没有实现，暂且放过。。。)</p><p><strong><font color="red">缩进</font></strong><br>  在输入法的「全角」模式下，输入两个空格键即可　<br>　　在全角模式下，首行缩进</p><p>其他markdonw语法使用频率不是很高，可参考Markdown<a href="http://markdownpad.com/">官网文档</a>，个人认为，掌握上面这些对于文本写作足矣！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to associate your blog site with a domain</title>
      <link href="/2016/10/10/2018-09-29-how-to-associate-your-blog-site-with-a-domain/"/>
      <url>/2016/10/10/2018-09-29-how-to-associate-your-blog-site-with-a-domain/</url>
      
        <content type="html"><![CDATA[<p>网站建起来了，怎么样通过百度，google搜索到你的站点呢？几乎每个建站人员都有类似问题，下面我从自身的Hexo Site实际经历来梳理下这个问题的解决方案。</p><ol><li><p>购买域名<br>从万网（阿里云）中购买域名，这个根据个人需要，可以选择不同后缀的域名，当然价格也是不一样的。另外能提供域名注册的机构有很多，阿里云是国内比较知名的站点，这里不仅购买方便，后续的维护和站点的稳定性也是有保障的。<br><a href="https://www.aliyun.com/?utm_content=se_1000301881">网址如下</a></p></li><li><p>解析域名<br>购买域名后并不能直接拿来使用，需要对其进行解析，所谓解析就是将你的域名指向你的网站服务器，这样当别人访问域名时将通过解析引导访问指向你的服务器。</p></li></ol><p> 域名解析在阿里云里很容易设置，网上有很多设置步骤，我的做法是直接将CNAME直接做两次引导，如下面设置<br><img src="/medias/domainAnalysis.GIF" alt="域名解析"></p><ol start="3"><li><p>实名认证<br>这个没得说，阿里云平台的必须步骤，没有经过实名认证的域名是不能正常使用的，平台将会把域名处于Serverhold状态，无法使用<br>实名认证后可以ping yourdomainName 来检验下是否该域名生效</p></li><li><p>将域名和Hexo Site关联起来<br>完成上述域名申请购买和认证后，接下来就对Hexo site做一些设置了，我的步骤如下</p></li><li><p>1 新建CANME文件（在hexo根目录下的source文件夹下）<br><font color="red">$ touch CNAME </font> (或者直接鼠标操作，注意不要任何后缀)</p></li><li><p>2 在CNAME里写上如下代码并保存<br><a href="http://www.yourdomainname.top/">www.yourdomainName.top</a></p></li><li><p>3 进入Github在hexo仓库下设置Source page domain 为<br><a href="http://www.yourdomainname.top/">www.yourdomainName.top</a></p></li><li><p>4 执行并部署网站<br>hexo clean<br>hexo g -d<br>or<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> domain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to migrate your blog to another PC</title>
      <link href="/2016/10/03/2018-09-27-how-to-operate-hexo-in-another-pc/"/>
      <url>/2016/10/03/2018-09-27-how-to-operate-hexo-in-another-pc/</url>
      
        <content type="html"><![CDATA[<p>有时候我们常常需要在另外的设备上更新博客，怎么办呢？这就需要将你部署在Github端（Github Pages）的博客原始文件更新到新的机器上，然后配置好相应的环境，这样就可以像在原始机器上工作一样正常些博客了，这么说，估计你还是云里雾里，不慌，下面就是我的详细步骤，照此来做就行了。</p><p>设计思路是在存放Blog的Github仓库里创建一个分支（比如Hexo）这样该仓库就有两个分支了（master和hexo），master分支存放的是hexo生成的静态blog页面，hexo就可以存放hexo的原始文件了，这样将来更换机器时，只需将hexo分支clone到新的终端机器即可。</p><h5 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a><font color="red">设计思路：</font></h5><blockquote><p><font color="#8ab" size="2.5"> 创建new branch <font color="yellow">–&gt;</font> 将hexo原始文件存放在new branch <font color="yellow">–&gt;</font> 在新的机器中clone该new branch <font color="yellow">–&gt;</font> 配置新机器的hexo环境 <font color="yellow">–&gt;</font> 新机器中更新blogs <font color="yellow">–&gt;</font> git push更新到new branch <font color="yellow">–&gt;</font> hexo生成静态页面并部署到master branch （hexo clean hexo g hexo d）</font></p><font color="#8ab" size="2.5"></font></blockquote><font color="#8ab" size="2.5"><span id="more"></span><h5 id="实施步骤："><a href="#实施步骤：" class="headerlink" title="实施步骤："></a><font color="red">实施步骤：</font></h5><ol><li><p>在新的机器上安装Nodejs，Git</p></li><li><p>在新的机器上创建hexo根目录文件夹</p></li><li><p>在新的blog根目录下安装Hexo，如果之前有安装，并不在该目录，请忽略该步</p><pre class="line-numbers language-none"><code class="language-none">$ npm install -g hexo (-g是代表全局global安装)或者执行命令$ sudo npm install -g hexo (有时可能因为权限不够，需要在前面加上 sudo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Clone你的blog仓库从Github端到新的blog目录</p><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/yourname/hexo-test.github.io.git (将该命令中的仓库换成你自己的hexo blog仓库就行)git clone https://github.com/yourname/hexo-test.github.io.git(将该命令中的仓库换成你自己的hexo blog仓库就行) &lt;font color="red"&gt;newblogFolderPath&lt;/font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果在Github创建仓库时能创建新的分支，那最好了，如果没有（大多数人应该没有考虑到这点）那只好重新创建一个分支如hexo了（该命令要在新机器blog根目录执行）</p><pre class="line-numbers language-none"><code class="language-none">$ git branch 'hexo' (创建新的git分支hexo)$ git checkout 'hexo' (切换分支到hexo)或者执行如下命令$ git checkout -b 'hexo' (创建并切换到hexo分支)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将新blog根目录下所有的文件删除（就是上一步从github仓库clone的文件），把原机器中hexo根目录下的所有文件copy过来（当然有些可以不用copy如果你知道哪些文件不需要的话，建议全部copy）</p></li><li><p>把copy过来的文件提到暂存区</p><pre class="line-numbers language-none"><code class="language-none">$ git add --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>提交暂存区文件到分支</p><pre class="line-numbers language-none"><code class="language-none">$ git commit -m "commit orign hexo file" (引号中的内容就是description自定义，但要有意义)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>推送分支到github</p><pre class="line-numbers language-none"><code class="language-none">$ git push --set-upstream origin hexo (hexo是新分支的名称)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ul><li><p>到这一步我们就基本上搞定了，以后再跟新了博客就直接 git push就可以了，hexo的操作跟以前一样不变。</p></li><li><p>经过上面的步骤后，我们就把原机器中hexo的原始文件，搬到了github hexo仓库的hexo分支上了。这么做的好处就是以后无论在哪一台机器上更新blog，直接clone这个hexo分支到本地，npm install安装依赖之后就可以用了。 最后写好博客，直接执行如下命令即可将更新的blog部署到master分支上。</p><pre class="line-numbers language-none"><code class="language-none">$ hexo -clean -g -d或者分别执行hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><font color="red">小结：</font></h5><blockquote><p>几个常用的命令 -<br>查看分支：git branch<br>创建分支：git branch <name><br>切换分支：git checkout <name><br>创建+切换分支：git checkout -b <name><br>合并某分支到当前分支：git merge <name><br>删除分支：git branch -d <name></name></name></name></name></name></p></blockquote><blockquote><p>几个常用的Hexo依赖 -<br>本地测试的时候需要用hexo server<br>npm i hexo-server<br>将文章部署到github上的模块<br>npm install hexo-deployer-git –save<br>安装RSS插件<br>npm install hexo-generator-feed –save<br>添加Sitemap,加速网页收录速度<br>npm install hexo-generator-sitemap –save</p></blockquote><blockquote><p>再次回到原始机器该怎么做呢<br>需要clone hexo分支，然后再更新blog，和上面新机器一样操作，或者直接将source文件夹更新就可以了（因为影响部署静态文件的，应该是source中的内容）</p></blockquote><table><tbody><tr><td bgcolor="#54FF9F">另外，如果本地创建的Hexo架构部署失败后（比如单个文件超过100MB的，在hexo d就会报错，这个坑我到现在还没找到solution），可以快速补救，现将补救步骤描述如下 -1. 在本地在穿件一个文件夹作为blog根目录, 并将source, theme 以及_config.yml 文件copy过来（其实就是复制原来的hexo架构） 2. 在该目录下打开Git Bash or Commond Line2.1 在git命令框中安装Hexo (执行命令： npm install -g hexo)* 这一步基本不需要做，因为这里是补救之前的hexo + Github框架，这些之前都有安装过，所以不必重复安装3. 执行命令： hexo ini4. 执行命令： hexo g5. 执行命令： hexo d* 如果出错，请依次执行这几个命令： npm install hexo-deployer-git --save； sudo npm install hexo-server； npm install hexo-server --save</td></tr></tbody></table></font>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试管理修炼之测试管理体系建设</title>
      <link href="/2016/03/20/2018-09-18-ce-shi-guan-li-xiu-lian-zhi-ce-shi-guan-li-ti-xi-jian-she/"/>
      <url>/2016/03/20/2018-09-18-ce-shi-guan-li-xiu-lian-zhi-ce-shi-guan-li-ti-xi-jian-she/</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试的价值"><a href="#1-测试的价值" class="headerlink" title="1. 测试的价值"></a>1. 测试的价值</h2><pre class="line-numbers language-none"><code class="language-none">应该体现在- 测试工作或技术对项目流程的渗透，以及在整体产品生命周期中主动质量控制以及对生产流程的改进和完善应该是测试终极价值的体现，这并非是一两个测试技术高手，或引入几个测试技术能解决的事情。从整个产品的链条来看，测试和其他环节一样重要，是整个产品不可或缺的关键节点。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-软件开发生命周期大致分为"><a href="#2-软件开发生命周期大致分为" class="headerlink" title="2. 软件开发生命周期大致分为 -"></a>2. 软件开发生命周期大致分为 -</h2><blockquote><p><font color="#dd0000" face="黑体"> 需求计划（产品部门）–&gt; 概要设计（研发部门、产品部门）–&gt;详细设计（研发部门）–&gt;编码实现/Coding（研发部门）–&gt; 测试(测试部门) –&gt; 验收（产品部门）</font></p></blockquote><ul><li>该过程是产品生命周期的必然体现。无论采取哪种开发模式(瀑布式，敏捷模式)都应该遵行该过程，开发模式的不同主要体现在开发效率上，而并非要违反产品的生命周期。<span id="more"></span></li></ul><h2 id="3-测试体现建设的整体思路"><a href="#3-测试体现建设的整体思路" class="headerlink" title="3. 测试体现建设的整体思路"></a>3. 测试体现建设的整体思路</h2><p>测试管理体系是一个系统工程，要建设测试管理体系要从构成该系统的过程加以识别和管理，以实现设定的系统目标，同时要确保各个过程协同作用相互促进。从而使它们的总体作用大于各个作用之和。 建设测试体现的宗旨就是让测试渗透到软件生命周期的各个环境，从而更早的发现和排除缺陷。</p><h4 id="测试体系的建设可以从如下几个方面-过程来考量："><a href="#测试体系的建设可以从如下几个方面-过程来考量：" class="headerlink" title="测试体系的建设可以从如下几个方面/过程来考量："></a>测试体系的建设可以从如下几个方面/过程来考量：</h4><ol><li><p>测试规划（Test Strategy）- 确定各测试阶段的目标和策略，明确各测试阶段的活动安排，时间节点和资源配置（如人员安排，设备安排，技术及其他安排等）以及跟踪<br>和控制测试过程的活动等内容；该过程输出测试计划（Test Plan）。如需求阶段要完成验收计划（UAT 计划），概要设计阶段要完成系统测试计划，详细设计阶段要完成集成测试计划（SIT 计划），编码阶段要完成单元测试计划（Unit Test 计划）任何对计划的修改都要提交评审组评审（评审组通常由项目的各个相关方组成，如产品人员，开发人员，测试以及QA人员等）</p></li><li><p>测试设计 - 即根据测试计划设计测试方案，该过程输出测试用例（Test Case），此过程与软件开发活动同步进行，其结果可作为各阶段测试计划的附件进行提交审核。</p></li><li><p>测试实施 - 就是根据测试用例来执行测试，并对结果进行对比，记录，缺陷跟踪和管理等活动，最终得到测试报告（Test Report）</p></li><li><p>配置管理 - 是软件管理的子集，作用于测试的各个阶段（即需求阶段，概要阶段，详细设计阶段，编码阶段，验收阶段等）， 管理对象包括测试计划，测试用例，测试版    本，测试结果，测试工具以及环境等内容。</p></li><li><p>资源管理 - 包括对人力资源和工作场所，以及相关设施和技术支持的管理。如果有专用实验室，还有其他管理等内容覆盖。</p></li><li><p>测试管理 - 即采取使用的方法对上述过程及结果进行监视，并在适用时进行测量，以保证过程的有效性，如果发现过程没有达到预期的效果，还可进行适当的调整或纠<br>正。</p></li></ol><ul><li>以上六个过程可作为建设软件管理体系的实施步骤，首先要确定软件测试所需的过程和应用（根据公司实际情况从六大步骤中选择确定）；然后就是要确定这些过程的顺序和相互作用；确定这些过程所需的准则和方法，一般应制定这些过程形成文件的程序，以及监视，测量和控制的标准和方法（这一步可参考TMMI标准来进行制定）。从以上六个过程中可以看出，测试阶段要产出的文件有： Test Strategy， Test Plan， Test Case， Test Report （test Bug tracking）</li></ul><h2 id="4-建立测试管理体系的理论依据"><a href="#4-建立测试管理体系的理论依据" class="headerlink" title="4. 建立测试管理体系的理论依据"></a>4. 建立测试管理体系的理论依据</h2><p>CMM(Capability Maturity Model)- 能力成熟度模型，是软件界的广泛使用的过程度量模型，旨在提升软件各个环节的作业标准，推动整个行业朝着更加规范，更加科学，也更加可控的方向发展。CMM是软件发展的必然产物，是被反复证明确实能帮助企业和产品提升自身竞争力的事实依据。也得到了国际上绝大多数软件厂商的认可和积极参与，获得CMM国际认证也成了各大软件公司的追求目标。既然如此，测试作为软件生产必不可少的一环，制定和CMM标准相匹配的测试管理体系就显得尤为重要了。事实上在测试界也有与之对称的标准，称之为TMM。废话少说，下面我简要介绍下TMMi和CMMi的相关规范和等级定义，了解和熟悉这些规则是管理测试团队的重要理论依据。</p><h4 id="CMMi的五级定义："><a href="#CMMi的五级定义：" class="headerlink" title="CMMi的五级定义："></a>CMMi的五级定义：</h4><ol><li>Initial （初始级）- 处于这个级别的组织，基本没有健全的软件工程管理制度。每件事情都是以<br> 特殊的方法来做，事情的成败取决于团队成员的个人能力，具有很大的偶然性，人员变动，则一切都跟着改变，处处充满危机，软件生产随意性很大，基本无法可依，无章可循。</li></ol><ul><li>Repeatable （可重复级） - 在这一级别的团队，有些基本的软件项目管理行为，主要是参考之<br>  前项目经验，借鉴一些具体措施，可以预防一些危机的发生。</li><li>Defined （已定义级）- 在这一级别的团队，已为软件的生产编制了完整的文档，软件过程管理<br>  和技术方面都有明确的定义，也采取了评审的办法来保证软件的质量。对生产过程的管理具有随意性，并不能严格的管理过程。</li><li>Manage（已管理级） - 一个处于第4级的公司对每个项目都设定质量和生产目标。这两个量将被不断地测量，当<br>  偏离目标太多时，就采取行动来修正。利用统计质量控制，管理部门能区分出随机偏离和有深刻含义的质量或生产目标的偏离</li><li>Optimizing （已优化级）—个第5级组织的目标是连续地改进软件过程。这样的组织使用统计质量和过程控制技术作为指导。从各个方面中获得的知识将被运用在以后的项目中，从而使软件过程融入了正反馈循环，使生产率和质量得到稳步的改进。达到该级的公司可自发的不断改进，防止同类缺陷二次出现。</li></ul><h4 id="TMMi的五级定义："><a href="#TMMi的五级定义：" class="headerlink" title="TMMi的五级定义："></a>TMMi的五级定义：</h4><ul><li>和CMMi类似，TMMi也分五个等级进行定义，其大意和CMMi相当，这是在软件测试白皮书上摘抄的定义 -</li></ul><ol><li><font color="#dd0000" face="Gill Sans MT" size="3"> Initia </font> –Similar CMM, no plan and system to test activities. Random and no document tracing</li><li><font color="#dd0000" face="Gill Sans MT" size="3">Phase Definition </font> - Establish basic techniques and methods, develop testing and debugging goals</li><li><font color="#dd0000" face="Gill Sans MT" size="3">Integration </font> - Establish test organization, integration testing into the project lifecycle, establish technical training<br>programmer and control and monitor testing</li><li><font color="#dd0000" face="Gill Sans MT" size="3">Management and Measurement </font> - Establish organizational review programmer; Establish test measurement programmer; software quality evaluation</li><li><font color="#dd0000" face="Gill Sans MT" size="3"> Optimization, defect prevention and quality control</font> - use process data for defect prevention; quality control; Test process optimization</li></ol><ul><li>Tmm 和 CMM类似，有些书上对他们的定义完全相同，他是在CMM的基础上发展而来的，目的是提高软件生产团队的效率，它只是一种形式测试，并不代表软件本身的质量，它是检验你的软件生产是否遵循了一定的程序，是否有相应的管理措施和监管措施，不涉及软件本身内容。只是检测程序的形式，是否有各种会议，步骤等，至于会议开了什么内容，没有任何关系。CMMi-5是最高水平，取得CMMi5的最多的国家是印度，但是印度的软件质量很差，这折射了这种形式测试的局限性. 作为测试管理者，不应该只局限于这些规范和标准，要根据各自公司的实际，制定符合自身阶段的测试体系。一味追求高等级的认证标准，很容易让测试流于形式，适得其反。</li></ul><h2 id="5-如何开展敏捷软件测试活动"><a href="#5-如何开展敏捷软件测试活动" class="headerlink" title="5. 如何开展敏捷软件测试活动"></a>5. 如何开展敏捷软件测试活动</h2><p>上面介绍了如何建立软件测试体系和遵行的理论依据，这里我就自身经验，结合网上大咖的梳理，介绍下敏捷软件测试活动展开的具体步骤，仅供大家参考。</p><ul><li><font color="#dd0000" face="Gill Sans MT" size="3">测试需求</font><br>收集和整理本迭代中的所有需求（主要体现为新增功能和原有功能的修改），建议以在线文档（例如google的google docs, Tencent的协同办公软件）的方式管理每个迭代中的需求变化。通常需要对来自产品的需求进行一定程度的细化，细化到本产品的测试工程师能够清楚理解需要验证的点即可，同时测试需求通常需要与产品负责人和开发组确认（非正式评审）。</li><li><font color="#dd0000" face="Gill Sans MT" size="3">测试计划</font><br>“一页纸（One Page）”的测试计划是一个很好的实践。测试计划中只需要包含本次迭代的目标，以及简单的时间和资源计划即可。</li><li><font color="#dd0000" face="Gill Sans MT" size="3">测试设计与执行</font><br>敏捷测试中的测试设计与执行通常是交织在一起的，对于新功能，测试工程师通常通过对新功能的使用和尝试来了解之，然后为其设计测试用例并用脚本（手工测试用例或自动化脚本）的方式将其固定下来；而对于原有功能的测试主要依靠自动化测试来进行。在测试设计阶段，测试工程师需要维护验收测试，以保证其准确地反映了每个迭代的目标。推荐使用在线表格或是轻量的用例管理软件对用例进行管理，在自动化程度比较高的情况下，甚至可以直接依赖测试需求列表和自动化测试脚本，而无需创建手工用例集合。</li><li><font color="#dd0000" face="Gill Sans MT" size="3">测试评估总结</font><br>测试评估总结意味着对每个迭代中进行的测试进行评估与总结。与传统的测试相同，敏捷测试中评估的主要目的同样是获得被测产品质量与测试质量的度量。</li></ul><p>总之，敏捷的软件测试工作不要拘泥于形式和文档，要将TMM精神体现在测试思维和执行力上，最大限度的确保测试完整性和覆盖率。在此基础上再进一步完善测试流程和归档整理。</p>]]></content>
      
      
      <categories>
          
          <category> 测试管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试流程 </tag>
            
            <tag> 测试体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能测试之LR经典案例</title>
      <link href="/2015/11/04/2018-09-24-xing-neng-ce-shi-zhi-lr-jing-dian-an-li/"/>
      <url>/2015/11/04/2018-09-24-xing-neng-ce-shi-zhi-lr-jing-dian-an-li/</url>
      
        <content type="html"><![CDATA[<p>Performance 测试也是自动化测试的一个重点领域，了解和掌握这一部分内容，也是完善自动化测试技能的一个补充。Performance测试包含的内容很多，这可以从其支持的协议看出。但日常测试中往往集中在HTML，WebService等协议，这里我将以实际的测试用例来详细介绍如何利用LR（Load Runner）来实现这类Cases的性能测试。先来看几个Cases。</p><span id="more"></span><h6 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h6><p>关于Web Service的案例，通常我们遇到最多的Cases类似于下面的步骤，这应该是Web Services的标准测试步骤了，也是PT中测试WebService最常用的步骤。先来了解下，后面再来看怎么脚本实现。</p><h6 id="1-Case-One-–"><a href="#1-Case-One-–" class="headerlink" title="1. Case One –"></a>1. Case One –</h6><ul><li>Step1： Get WSDL from URL、File、UDDI （<a href="http://mdm-itg.houston.hp.com:8180/customer-">http://mdm-itg.houston.hp.com:8180/customer-</a><br>manager/services/CompetitorService?wsdl）</li><li>Step2：Initialize Parameters with Customer IDs</li><li>Step3：Execute Search operation to get the response</li></ul><h6 id="2-Case-two-–"><a href="#2-Case-two-–" class="headerlink" title="2. Case two –"></a>2. Case two –</h6><p>关于HTML的案例，这部分Cases包含的情况很多，主要是因为基于Html的操作很普遍，比喻页面登录，查找，比较，搜索等等，都是常见的测试，这里我也提炼了一些基本的步骤，不一定全面，但却是可以代表很大一部分基于Html操作的PT方案。</p><ul><li>Step1：Get the URL for portal</li><li>Step2：Login with account</li><li>Step3：Initialize with Pramenters</li><li>Step4：Execute Searching and get the response</li></ul><p>上面两中情况的性能测试在软件测试中出现的比率很高。熟练理解和编写这类脚本可以让我们轻松对付performance测试中80%以上的Cases. （呵呵。。。别拍砖，个人就是这么认为的）</p><p>这部分内容要怎么介绍呢？采取类似于AT的，一个案例一个案例的说比较乏味，也不太容易理解。因为基本上就是脚本代码重复Copy和Review。不具有参考性。还是围绕这两类Cases步骤，以及与其相关的知识点逐一展开吧。</p><h6 id="脚本设计"><a href="#脚本设计" class="headerlink" title="脚本设计"></a>脚本设计</h6><p>Performance 测试不同于AT，通常我们主张用Recording的办法来录制脚本，这样做不仅可以节省时间，而且对脚本中的各种Action（如 .CSS , .Do，.Json或者Jave Script， Asp等等控件）能够很好的识别。对于脚本的维护也是显而易见的。请看下面的脚本实现。</p><h6 id="For-Case-one-–"><a href="#For-Case-one-–" class="headerlink" title="For Case one – "></a><font color="red">For Case one – </font></h6><p>1.）录制WebService脚本</p><pre class="line-numbers language-none"><code class="language-none">web_service_call( "StepName=customSearchLookupService_101","SOAPMethod=CustomerLookupEnWebServiceService|CustomerLookupEnWebSe rvicePort|customSearchLookupService","ResponseParam=response","Service=CustomerLookupEnWebServiceService","ExpectedResponse=SoapResult","Snapshot=t1395726342.inf",BEGIN_ARGUMENTS,"xml:customSearchLookupService1="    "&lt;customSearchLookupService1&gt;"        "&lt;customerId&gt;{CustomerId}&lt;/customerId&gt;"    "&lt;/customSearchLookupService1&gt;",END_ARGUMENTS,BEGIN_RESULT,END_RESULT,LAST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意Web_Service_Call 用法,从面试的语法可知，Web_Service_Call 通常由<br>ExpectedResponse<br>specifications<br>StepName<br>参数构成，其他的都是optional. 用户可以根据实际情况选择使用。每个参数的定义可以从Help文档中查询，（F1: 查询函数用法）</p><p>2.）设置Checkpoint</p><pre class="line-numbers language-none"><code class="language-none">getValuefromResponse = lr_xml_find("XML={response}","Query=/Envelope[1]/Body[1]/customSearchLookupServiceResponse[1]/customerSearchLookup ResultGroup[1]/externalProfileGroup[1]/externalProfileLocatorBusinessLocatorNumber[1]/text()[1]", "Value=0709898899", LAST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.）判断Checkpoint的条件</p><pre class="line-numbers language-none"><code class="language-none">if (getValuefromResponse == 1){    lr_end_transaction("RequestAndResponse", LR_PASS);}else{    lr_end_transaction("RequestAndResponse", LR_FAIL);}return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>录制和设置Chekcpioint部分可以直接使用LR的界面完成，第三部需要手工编写Checkpoint条件。根据函数的语法（参见上面3.2部分内容）其实也不难完成。</p><p>Note：再次体会LR C语法的基本特点，每条语句都以分号结束。小括号内的每一参数赋值均已逗号结束，并且每条语句必须以双引号引用起来。引用变量值使用大括号{ }。另外，如果双引号里的内容又是被上引号引用的，那么就需要用反斜杠 “/”进行转换。（这在LR的help文件里有详细说明）</p><h6 id="For-Case-Two-–"><a href="#For-Case-Two-–" class="headerlink" title="For Case Two –"></a><font color="red">For Case Two –</font></h6><p>这部分脚本完全是手工编写的，目的就是如何利用上面介绍的函数来编写LR脚本。（如果可以录制的话，还是建议录制的办法，这里介绍的手工编写代码，仅供那些不能录制脚本的情况作为参考）</p><p>1.）Login URL</p><pre class="line-numbers language-none"><code class="language-none">使用”Action Function – Web_Submit_Data“函数发送URL请求web_submit_data("login.pl",    "Action=https://it-services-itg.external.hp.com/auth/login.pl",    "Method=POST",    "RecContentType=text/html",    "Referer=",    "Snapshot=t5.inf",    "Mode=HTML",    "EncodeAtSign=YES",    ITEMDATA,    "Name=action", "Value=logon", ENDITEM,    "Name=deviceos", "Value=2.0.0", ENDITEM,    "Name=devicetype", "Value=TouchPad", ENDITEM,    "Name=deviceNDUID", "Value=123", ENDITEM,    "Name=user", "Value=your email address", ENDITEM,    "Name=password", "Value=your nt account", ENDITEM,    "Name=osType", "Value=WebOS", ENDITEM,    LAST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意相关参数的设置，同样可以参考Help文档设置Web_Submit_Data函数。接下来就是Search操作了，由下面的函数实现。</p><p>2.）Search with the specified initialization</p><pre class="line-numbers language-none"><code class="language-none">web_reg_find("Search=Body",    "SaveCount=findcount",    "Text=SDGT",    LAST); status = web_url("rplAnywhere-web",    "URL=https://it-services-itg.external.hp.com/onebox/rplAnywhere-     web_1_0_0/services/rpl?name=BIN%20LADEN&amp;countryCode=US",    "Resource=0",    "RecContentType=text/html",    "Referer=",    "Snapshot=t6.inf",    "Mode=HTML",    LAST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对照Web_URL语法，这里对三个必要参数赋值- Step Name, URL 和 Attribute list. 除了这个函数外，还可以用其他函数如 web_submit_data, web_URL 代替。他们都属于Action Function. 同样可达到发送URL请求的目的。</p><p>接下来就是Checkpoint检查了，代码如下</p><p>3.) Checkpoint Setting and Validation</p><pre class="line-numbers language-none"><code class="language-none">lr_output_message("request status :%d", status);lr_output_message("find count :%d", atoi(lr_eval_string("{findcount}")));if (atoi(lr_eval_string("{findcount}")) &gt; 0){//check the times of finding 'SDGT' string        lr_output_message("found the value at the return page");        lr_end_transaction("AdhocSearching", LR_PASS);    }    else{        lr_output_message("found fail");        lr_end_transaction("AdhocSearching", LR_FAIL);                        }return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处的函数的理解可参考上面的解析。这里不再重复了。到此为止，两种案例的代码实现介绍完毕，是不是还是感觉云里雾里？很正常，这主要是因为LR的C实现函数参数太多，而且使用起来也不是很有感觉。</p><p>比喻说调用Web_Custom_request函数发送URL请求。那么函数Web_Custom_request到底该参数化哪些参数？每个参数的值该如何获取？还是没有一个直观的认识。这也是你尽管看了上面那些函数解析后后任然不知所措的根本所在。这是个难点。但我们有办法破解 </p><ul><li><p>方法一： 如何识别哪些方法需要被Action Function提取这是手工开发LR代码的必要步骤，你首先要知道哪些页面方法需要被Action Function提取，找出这些方法，然后调用Action Function函数予以实现。难就难在找出这些方法上。看好下面的介绍，解决上面问题的solution就要出来了 – 进入相关页面，进入代码视图，进入Network视图，反复操作页面，看哪些方法的response是关联下一个步骤的。把这些方法提出来，一 一调用Action Function 函数予以实现。 好了这就是要领 。(这里主要是针对record困难的Chrome环境。 按F12进入)不知道？还是不知道？那你打开一个GUI界面（IE或者Chrome都可以）进入代码视图模式，反复进行页面操作（如login），然后在Network视图里看看哪些方法被识别出来了，再看看这些方法的response，有哪些跟下一步骤的界面相关就提出来。这就是Action Function的函数要去实现的步骤。就这么简单。实在不会的话，就按照上面的介绍反复操练吧，知道熟练找出页面方法为止。</p></li><li><p>方法二： 如何识别哪些方法需要被Action Function提取请使用第三方工具来帮助提取。这里推荐使用Fiddler工具，这个工具可以很方便的看出页面操作对象以及方法属性。用它可以提高我们的代码开发效率，有兴趣的童鞋不妨试试。个人感觉还是不错的。使用它可以帮我们快速找出页面相关元素，以及相应方法，找到这些方法和元素后，跟方法 一 一样，我们需要将这些方法和元素以函数的形式表述出来。<br>这就是LR C脚本开发应该遵行的规则。当然如果能record的话，还是建议大家record。毕竟系统自动抓出的方法和属性要比手工去添加的来得快和准。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能测试 </category>
          
          <category> Performance Testing </category>
          
          <category> LR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> Performance Testing </tag>
            
            <tag> LR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Outlook的自动化脚本设计</title>
      <link href="/2015/10/26/2018-09-24-ji-yu-outlook-de-zi-dong-hua-jiao-ben-she-ji/"/>
      <url>/2015/10/26/2018-09-24-ji-yu-outlook-de-zi-dong-hua-jiao-ben-she-ji/</url>
      
        <content type="html"><![CDATA[<h6 id="基于Outlook邮件的测试用例自动化实现"><a href="#基于Outlook邮件的测试用例自动化实现" class="headerlink" title="基于Outlook邮件的测试用例自动化实现"></a><font color="red">基于Outlook邮件的测试用例自动化实现</font></h6><p>如何自动化操作Outlook也是大家比较关心的话题，有些Application有邮件发送功能，对这部分功能进行测试，我们常常会收到一封邮件，判断邮件的接受与否往往是断定测试成败的一个参考。同时我们也希望把测试的结果以邮件的形式自动发送给客户。这些涉及到对邮件应用程序接口的操作，下面我大概总结下这些常见功能的用法。</p><p>跟其他应用程序一样，Outlook也也为用户保留了一个统一的编程接口MAPI，使用这个接口提供的方法和属性，我们可以轻松的操作Outlook. 先来介绍了如何自动发送邮件功能吧。</p><span id="more"></span><h6 id="1-运用QTP-UFT如何自动发送Outlook邮件"><a href="#1-运用QTP-UFT如何自动发送Outlook邮件" class="headerlink" title="1. 运用QTP/UFT如何自动发送Outlook邮件"></a>1. 运用QTP/UFT如何自动发送Outlook邮件</h6><p>这个功能相信很多做测试的人都期待实现。特别是当测试完成后自动发一封邮件给相关人员，是不是感觉特别专业？好了，废话少说，直接给代码实现。下面的函数将发送一封邮件给相关人员，并加载一附件。</p><pre class="line-numbers language-none"><code class="language-none">Function SendA_Mail_to_SpecifiedPeople(maiTo, mailCC, mailBCC, subject, mailbody, attchedFile)    Set mailObj = CreateObject("Outlook.application")    set mailMsg = mailobj.CreateItem(olMailItem) '创建一封新邮件。          'Set mailSpc = mailobj.GetNamespace("MAPI")    mailMsg.to = maiTo    mailMsg.CC = mailCC    mailMSG.BCC = mailBCC    mailMsg.Subject = subject    mailMsg.body = mailbodymailMsg.Importance = olImportanceHigh    mailMsg.attachments.add attchedFile    mailMsg.sendmailMsg.Quit    Set mailObj = Nothing    Set mailMsg = NothingEnd Function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是很简单？还不快试试。这里需要强调一点的是CreateIte()方法，它可以创建Outlook支持的各种邮件类型。CreateItem(olMailItem)方法最常用。它封装了新建邮件的基本功能。</p><h6 id="2-检测Outlook-Top文件夹"><a href="#2-检测Outlook-Top文件夹" class="headerlink" title="2. 检测Outlook Top文件夹"></a>2. 检测Outlook Top文件夹</h6><pre><code>   这个功能也很实用，很多人在自己的邮箱里设置了不同时期的个人邮件夹，这里给出了如何识别并进入指定的邮箱文件夹。</code></pre><pre class="line-numbers language-none"><code class="language-none">Set myItem = CreateObject("Outlook.application")maxFile = myItem.GetNamespace("MAPI").Folders.CountFor i = 1 To maxFile        Set checkMailBoxFile = myItem.GetNamespace("MAPI").Folders(i)    Print checkMailBoxFileNext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序将打印出你的个人邮箱文件夹来。确定要进入那个邮箱，你也可以直接将参数i换成个人邮箱文件夹的名称。如想进入“2012.10-2013.10” 的邮箱，就将i替换成这个邮箱名即可。</p><h6 id="3-检索默认邮箱的文件夹"><a href="#3-检索默认邮箱的文件夹" class="headerlink" title="3. 检索默认邮箱的文件夹"></a>3. 检索默认邮箱的文件夹</h6><p>这个实例将检索默认邮箱的各个子文件夹</p><pre class="line-numbers language-none"><code class="language-none">Set myItem = CreateObject("Outlook.application")For i = 1 To 15    set mailBox = myItem.GetNamespace("MAPI").GetDefaultFolder(i)    msgbox mailBox    Print i &amp; " : "&amp; mailBoxNext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：<br>3 : 已删除邮件<br>4 : 发件箱<br>5 : 已发送邮件<br>6 : 收件箱<br>7 : 收件箱<br>8 : 收件箱<br>9 : 日历<br>10 : 联系人<br>11 : 日记<br>12 : 便笺<br>13 : 任务<br>14 : Reminders</p><p>有了这个清单，我们很容易进入相关的文件夹。比喻想检索收件箱，我们只需将变量i设置为6，7，8即可。每个人的默认邮箱设置可能不同，这个清单值也有可能会不一样。有兴趣的话可以自己测试下。</p><p>接下来就是查看收件箱里的邮件了，下面我将给大家介绍几个常用的方法。有了这些 方法，我们可以查看是否有新的邮件进来，是否属于测试过程中产生的邮件。我想这也是大家最感兴趣的功能点了。一起来看看下面的实现。</p><h6 id="4-检索默认邮箱的Inbox文件夹"><a href="#4-检索默认邮箱的Inbox文件夹" class="headerlink" title="4. 检索默认邮箱的Inbox文件夹"></a>4. 检索默认邮箱的Inbox文件夹</h6><p>先来看看如何进入默认邮箱的收件夹（Inbox）和如何检索Inbox里的各个子文件夹。请看下面的代码。</p><pre class="line-numbers language-none"><code class="language-none">Set myItem = CreateObject("Outlook.application")countFolders = myItem.GetNamespace("MAPI").GetDefaultFolder(6).Folders.CountFor i = 1 To countFolders    Set getEachFolder = myItem.GetNamespace("MAPI").GetDefaultFolder(6).Folders._    Item(i)    Print i &amp; "： " &amp; getEachFolderNext<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是对我的邮箱运行后的测试结果，请参考。<br>1： Automation Community<br>2： Boss’ Mail<br>3： China_SalesIT_DevTeam<br>4： Conversation History<br>5： CQ Team<br>6： Customer’s Mail<br>7： Deleted Items<br>8： EnglishCorner_Datum<br>9： Important Notices<br>10： Inida_Chandrababu<br>11： Inida_Vijay<br>12： ITI_ChianTeam<br>13： ITI_Customer<br>14： MDA_Team<br>15： PDIM_NA<br>16： Press_Team<br>17： Private Mail<br>18： SalesIT-MDMIT<br>19： ATPT</p><p>基于收件夹里的这些子文件夹，也许你要问，我想知道ATPT文件夹里的邮件个数和未读邮件个数。那么该怎么做呢？ 请看下面的代码。</p><h6 id="5-检索收件箱里指定文件夹的邮件"><a href="#5-检索收件箱里指定文件夹的邮件" class="headerlink" title="5. 检索收件箱里指定文件夹的邮件"></a>5. 检索收件箱里指定文件夹的邮件</h6><p>下面的代码实现了查看ATPT文件夹的邮件数，未读邮件数，指定发件人的邮件数以及符合邮件主题的未读邮件数。这些功能正好可以用来检查我们是否能收到应用程序向我们发送的邮件。 是不是很激动？</p><pre class="line-numbers language-none"><code class="language-none">Set myItem = CreateObject("Outlook.application")Set checkInboxFolder = myItem.GetNamespace("MAPI").GetDefaultFolder(6).Folders.Item("ATPT")mailCount = checkInboxFolder.Items.CountunreadMailCount1 = checkInboxFolder.UnReadItemCount  ‘此句等同于下面的语句unreadMailCount2 = checkInboxFolder.Items.Restrict("Not [Unread] = 'True'").Count’此句等同于上面的语句Print "TotalMailCount :" &amp; mailCount &amp; vblf &amp;_"unreadMailCount1 : " &amp; (unreadMailCount1) &amp; vblf &amp;_"unreadMailCount2 : " &amp; unreadMailCount2unreadMailCount3 = checkInboxFolder.Items.Restrict("[TO] = 'Yuan, Hong-Bo (Alan, HPIT-DS-TCoE)' And Not [Unread] = 'True'").Countprint "unreadMailCount3 : " &amp; unreadMailCount3unreadMailCount4 = checkInboxFolder.Items.Restrict("[CC] = 'Yuan, Hong-bo' And Not [Unread] = 'True'").Countprint "unreadMailCount4 : " &amp; unreadMailCount4unreadMailCount5 = checkInboxFolder.Items.Restrict("[BCC] = 'Ning Zhu' And Not [Unread] = 'True'").Countprint "unreadMailCount5 : " &amp; unreadMailCount5unreadMailCount6 = checkInboxFolder.Items.Restrict("[FROM] = 'Ning Zhu' And Not [Unread] = 'True'").Countprint "unreadMailCount6 : " &amp; unreadMailCount6执行后程序打印结果如下：TotalMailCount :11unreadMailCount1 : 3unreadMailCount2 : 3unreadMailCount3 : 3unreadMailCount4 : 0unreadMailCount5 : 0unreadMailCount7 : 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-检索收件箱指定文件夹里指定的邮件"><a href="#6-检索收件箱指定文件夹里指定的邮件" class="headerlink" title="6. 检索收件箱指定文件夹里指定的邮件"></a>6. 检索收件箱指定文件夹里指定的邮件</h6><p>其实上面的方法应该足以帮助我们应对那些有关Outlook的测试用例了。当然我们也可以深入邮件内容去检查，看是否有满足需求的邮件存在。常用的方法是还是调用olMailItem的方法去实现。</p><p>例如，这里ATPT文件夹里有一份title为这样的邮件，我们需要检验是否存在这样的一份邮件。怎么写脚本呢？</p><pre class="line-numbers language-none"><code class="language-none">Mail Title ：Announcement: our project ‘ABC’ will release 2.09 from 9:30am to 1:00pm on 6/30/2014 (UTC Time)Set myItem = CreateObject("Outlook.application")Set checkInboxFolder = myItem.GetNamespace("MAPI").GetDefaultFolder(6).Folders.Item("ATPT")checkInboxFolder.DisplaySet specifiedMails = checkInboxFolder.Items.Restrict("[subject] = 'Announcement: our project ‘ABC’ will release 2.09 from 9:30am to 1:00pm on 6/30/2014 (UTC Time)'")Msgbox specifiedMails.Count'检索有多少封title为指定内容的邮件Set specifiedMails = checkInboxFolder.Items.Restrict("[subject] = 'Announcement: our project ‘ABC’ will release 2.09 from 9:30am to 1:00pm on 6/30/2014 (UTC Time)' And Not [Unread] = 'True'")Msgbox specifiedMails.Count'检索有多少封title为指定内容的邮件并且状态是未读的Set specifiedMails = NothingSet checkInboxFolder = NothingSet myItem = Nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="点评："><a href="#点评：" class="headerlink" title="点评："></a>点评：</h6><blockquote><p>上面的几个案例主要围绕有关Outlook用例自动化的解说，一般来说，对任何外部引用程式的自动化都需要获得该应用程式的开放式用户接口，outlook提供了三个重要的GUI接口（Microsoft.Office.Interop.Outlook.MAPIFolder/ Microsoft.Office.Interop.Outlook.MailItem/ Microsoft.Office.Interop.Outlook.<br>_NameSpace），对这些接口方法的调用是实现自动化的测试的根本。这一届重点需要掌握的是CreateItem(olMailItem)，Folder，GetDefaultFolder以及Item等方法的使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
          <category> QTP/UFT </category>
          
          <category> Outlook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> QTP </tag>
            
            <tag> Outlook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Common Knowledge of Python - III</title>
      <link href="/2015/10/25/2018-10-25-the-common-knowledge-of-python-iii/"/>
      <url>/2015/10/25/2018-10-25-the-common-knowledge-of-python-iii/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章中重点介绍了Python的函数及其使用场景，这篇文章将重点放在Python类及文件操作上，也是通过简单的实例加强对类的认知。类是面向对象编程的一个根本，使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。这也是面向对象编程的魅力所在。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。</p><span id="more"></span><h3 id="类及其相关概念解析"><a href="#类及其相关概念解析" class="headerlink" title="类及其相关概念解析"></a>类及其相关概念解析</h3><p><strong>1.1 类及其相关属性说明</strong><br>还是先来看一个例子吧</p><pre class="line-numbers language-none"><code class="language-none">class Person():    """一次人的简单尝试"""    def __init__(self, name, sex, age, job):        """初始化属性- 姓名，性别，年龄，职业"""        self.name = name        self.sex = sex        self.age = age        self.job = job    def commonInfo(self):        judgeFlag =  "Do you wanna know a personal basic info. Yes or No?"        if judgeFlag == "yes":            print "the basic information is -\n", "Name - ", self.name, "\nSex - ", self.sex, "\n"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意Python类定义的结构，<font color="yellow" bgcolor="green">类名用大写字母开头（通常变量，函数用小写打头），后面接形参、括号并冒号后缩行。也有一种说法是变量，函数小写打头，如果是多单词构成的名称则后面每个单词首字母大写或者全部小写，单词间加下划线”_“分隔（即：驼峰命名法）</font></p><font color="yellow" bgcolor="green"></font></blockquote><font color="yellow" bgcolor="green"><blockquote><p>初始化函数initial（），用来对类型的<font color="red">实例绑定属性</font>，有了这个初始化函数定义，在编写类方法和调用类的时候，更加方便便捷。如下代码，如果没有经过init（）函数定义的类，是没有属性的。</p></blockquote><blockquote><p>在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#没有__init__()方法的类class Rectangle():    def getPeri(self,a,b):        return (a + b)*2    def getArea(self,a,b):        return a*brect = Rectangle()print(rect.getPeri(3,4))print(rect.getArea(3,4))print(rect.__doc__) # 打印类的说明print(rect.__dict__) # 打印类的属性#有__init__()方法的类class Rectangle():    def __init__(self):        self.side1 = a        self.side2 = b    def getPeri(self,a,b):        return (a + b)*2    def getArea(self,a,b):        return a*brect = Rectangle()print(rect.getPeri(4,4))print(rect.getArea(4,4))print(rect.__dict__) # 打印类的属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.2 类的继承及覆盖/重写</strong> -</p><pre class="line-numbers language-none"><code class="language-none">#define parent classclass Car(): # class Car: 也是okay的    '''模拟一个汽车实体的简单尝试'''    def __init__(self, make, model, year):        self.make = make        self.model = model        self.year = year        self.odometer_reading = 0    def get_description(self):        longName = str(self.year) + ' ' + self.make + ' ' + self.model        print "long name is ", longName        return longName.title()    def read_odometer(self):        print "This car has " + str(self.odometer_reading) + " miles on it."    def update_odometer(self, mileage):        if mileage &gt;= self.odometer_reading:            self.odometer_reading = mileage        else:            print "You are prohibited to roll back an odometer!"    def increment_odometer(self, miles):        self.odometer_reading += miles#myCar = Car('Honda', 'CRV', '2016-6')#print "\n\n\nThis is my first Car - ", myCar.get_description()#define child classclass ElectricCar(Car):    """这里是电动汽车的类型描述"""    def __init__(self, make, model, year):        """初始化父类属性"""        Car.__init__(self, make, model, year)    def read_odometer(self):        print "this is the electronic car, and its odometer will generate automatically! won't be changed by manual"myFirstCar = ElectricCar('Honda', 'CRV', '2016')print "My first car describle - ", myFirstCar.get_description()print "My first car odometer description &gt;&gt;&gt; ", myFirstCar.read_odometer()#define a new parent classclass Car(object):    '''模拟一个汽车实体的简单尝试'''    def __init__(self, make, model, year):        self.make = make        self.model = model        self.year = year        self.odometer_reading = 0    def get_description(self):        longName = str(self.year) + ' ' + self.make + ' ' + self.model        print "long name is ", longName        return longName.title()    def read_odometer(self):        print "This car has " + str(self.odometer_reading) + " miles on it."        #odometerDesc =  "This car has " + str(self.odometer_reading) + " miles on it."        #return odometerDesc    def update_odometer(self, mileage):        if mileage &gt;= self.odometer_reading:            self.odometer_reading = mileage        else:            print "You are prohibited to roll back an odometer!"    def increment_odometer(self, miles):        self.odometer_reading += milesclass ElectronicCar(Car):    def __init__(self, make, model, year):        super(ElectronicCar, self).__init__(make, model, year)mySecCar = ElectronicCar('Tesla', 'Model S', '2018-8')print "Return my second car information -", mySecCar.get_description()print "My second car odometer description &gt;&gt;&gt; ", mySecCar.read_odometer()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>子类如果重写了__init__ 时，要继承父类的构造方法，可以使用 super 关键字：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">super(子类，self).__init__(参数1，参数2，....)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一种经典写法如下 -</p><pre class="line-numbers language-none"><code class="language-none">父类名称.__init__(self,参数1，参数2，...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>虽然没有init（）的类可以使用，但代码写起来会很低效，这不是一个好的代码习惯，遵守约定是一个优秀程序员的需要具备的姿态。</p></blockquote><blockquote><p>字类不能继承父类praviate的属性和方法，在python中指的是加下划线或双下划线的属性及方法。</p></blockquote><p><strong>1.3 类的导入</strong><br>随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助， Python允许你将类存储在模块中，然后在主程序中导入所需的模块。<br>导入模块中的类和导入模块中的函数写法类似，参看如下表述 -</p><pre class="line-numbers language-none"><code class="language-none">导入单个类from car import Car导入多个类from car import Car, ElectricCar导入全部模块中的类from car import *或者import car<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><b>小结</b>-<font color="green">导入模块时，要么from，要么import；而函数或类只能import。<br>有了类可以更好的封装现实世界，并且高效和易于理解，这点是函数无法比拟的，尽管函数也常常用于封装。</font></p><font color="green"></font></blockquote><font color="green"><blockquote><p><font color="orange">实例化一个类就是类名+（）. ex. student = StudentClass()</font></p><font color="orange"></font></blockquote><font color="orange"><blockquote><p><font color="blue">和普通数相比，在类中定义函数只有一点不同，*<b>就是第一参数永远是类的本身<font color="red">实例变量self，在定义时不可以省略</font></b><font color="red"><em>, 并且调用时，不用传递该参数。除此之外，类的方法(函数）和普通函数没啥区别，你既可以用默认参数、可变参数或者关键字参数（</em>args是可变参数，args接收的是一个tuple，**kw是关键字参数，kw接收的是一个dict）</font></font></p><font color="blue"><font color="red"></font></font></blockquote><font color="blue"><font color="red"><blockquote><p>类是抽象的模板，而实例是根据类创建出来的一个个具体的对象，每个对象都拥有相同的方法，但各自的数据可能不同，这是学习OOP编程必须要建立的基本概念，由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法。</p></blockquote><blockquote><p><font color="pink">如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</font></p><font color="pink"></font></blockquote><font color="pink"><blockquote><p>在Python中，变量为为双划线开头的，如__xxx,是私有变量private，只能类的内部调用，外部对象是不能调用的；<br>变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量， 编程时变量名不要使用这样的命名；<br>单下划线开头的变量名类似这样_xxx的，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</p></blockquote><blockquote><p><font color="purple">继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；<br>有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；</font></p><font color="purple"></font></blockquote><font color="purple"><p><strong>1.4 类的多态、属性限制、装饰</strong><br>所谓多态 - 就是同一类事务有多种不同的形态，一个抽象类有多个子类，因而多态是依赖于继承的，也就是说每个子类可以对同一个消息有不同的响应方式。请看下面的例子 -</p><pre class="line-numbers language-none"><code class="language-none">'''继承和多态'''class Animal():    def run(self):        print "Animal can run .... "class Dog(Animal):    def run(self):        print "Dog also run and run fast."class Chick(Animal):    def run(self):        print "Chick not only run and also fly."animal = Animal()animal.run()animal1 = Dog()animal1.run()animal2 = Chick()animal2.run()class Pig(Animal):    passanimal3 = Pig()animal3.run()# define a new method, and make an instant of Animal as the parameter, so that we can see if the outputs are changed by the parameter.def runTwice(animal):    animal.run()    animal.run()runTwice(Animal())runTwice(Dog())runTwice(Chick())# another subclass of animalclass Horse(Animal):    def run(self):        print "Horse runs very fast, and it used to be widely used as a transportation"runTwice(Horse())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用_<em>slots</em>_</strong> 来限制class的属性，例如只允许对某一个类添加name，sex属性，可以这样来做</p><pre class="line-numbers language-none"><code class="language-none">class Enrollment(object):  __slots__ = ('name', 'sex') # 用tuple定义允许绑定的属性名称这样一来如果想给该类的对象绑定新的属性时就会报错，如 -s = Enrollment()s.name = 'alan's.sex = 'Male's.age = 33 # 此处age属性不允许被绑定，程序执行会报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类的装饰decrate</strong> 请参阅之前一篇文章介绍 。。。</p></font></font></font></font></font></font></font>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Common Knowledge of Python - II</title>
      <link href="/2015/10/24/2018-10-24-the-common-knowledge-of-python-ii/"/>
      <url>/2015/10/24/2018-10-24-the-common-knowledge-of-python-ii/</url>
      
        <content type="html"><![CDATA[<p>今天接着梳理Python之函数、类以及相关的知识点，通过简单的代码实例帮助消化这些具体的或抽象的概念对掌握一门编程语言尤为有用，一起来看看我是怎么整理的。<br><strong><font color="red">1. 函数</font></strong><br> </p><pre class="line-numbers language-none"><code class="language-none">def sayHelloToAnyone(): #&lt;font color="red"&gt; 1. 括号()不可少，即使没带形参，然后冒号 : 也是必须的，这是定义函数的基本特征&lt;/font&gt;    '''the purpose of this function aim to output greeting to ones you wan to say    created Date - 2015.10     ''' # 2. 这部分为函数的“文档字符串”用来生成程序中函数的文档。    print("Hello everyone, I am Pyhon, I love you all!")sayHelloToAnyone() # 3. 要调用函数，可依次指定函数名以及用括号括起的必要信息。 此处由于该函数不需要任何信息参数，所有直接函数名+（）即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  <span id="more"></span><br>  1.1 实参和形参<br>  <pre class="line-numbers language-none"><code class="language-none">def sayHelloToSpecialone(userName): # 形参    print("Hello", userName + " Nice to meet you again!")sayHelloToSpecialone('Alan') # 实参实参的位置和形参对应很重要，一定要注意顺序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>  1.2 关键字实参<br>  <pre class="line-numbers language-none"><code class="language-none">def myPets(name, color, character='Clever'):  print "I have a", name, "\nit's ", color, "\nand it's very", charactermyPets('Cat', 'Yellow', 'compliant')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><p>  输出为：</p><p>  I have a Cat<br>  it’s  Yellow<br>  and it’s very compliant</p>  <pre class="line-numbers language-none"><code class="language-none">myPets('Cat', 'Yellow')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  输出为：<br>  I have a Cat<br>  it’s  Yellow<br>  and it’s very Clever</p><p>  有时函数使用默认值时（关键字参数时），<font color="green">在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让Python依然能够正确地解读位置实参。</font></p><p>  1.3 函数返回值<br>  函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值。在函数中，可使用return语句将值返回到调用函数的代码行。<br>  调用返回值的函数时，需要提供一个变量，用于存储返回的值。如下面代码所示 -<br>  </p><pre class="line-numbers language-none"><code class="language-none">def get_formatted_name(first_name, last_name):  """返回整洁的姓名"""  full_name = first_name + ' ' + last_name  return full_name.title()musician = get_formatted_name('jimi', 'hendrix')print(musician)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>另外，函数可以传递列表，以及在函数中修改列表，这些在现实编码中很常见，关键就是在函数中实现对列表的操作。有时要防止函数对传入列表的操作，可以传入该列表的副本，如 - function_name(list_name[:])</p></blockquote><p>  1.4 传递任意数量的实参<br>  形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个&lt;font color=’blue’ font-weight:’bold’ size=3&gt;元组中。<br>  </p><pre class="line-numbers language-none"><code class="language-none">def make_pizza(*toppings):  """打印顾客点的所有配料"""  print(toppings)  make_pizza('pepperoni')  make_pizza('mushrooms', 'green peppers', 'extra cheese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><blockquote><p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。 Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p></blockquote><blockquote><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对,这就是使用任意数量的<font color="purple" size="3">关键字实参</font>请看下面代码 -</p><blockquote><pre class="line-numbers language-none"><code class="language-none">def build_profile(first, last, **user_info):  """创建一个字典，其中包含我们知道的有关用户的一切"""  profile = {}  profile['first_name'] = first  profile['last_name'] = last  for key, value in user_info.items(): # 关键字实参就是字典数据型参数；任意实参其实就是元组型数据参数      profile[key] = value  return profileuser_profile = build_profile('albert', 'einstein', location='princeton', field='physics')print(user_profile)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></blockquote><p> 1.5 Python模块<br> 为什么把这个概念放在这里，是因为函数常常被放在python模块中，所谓模块就是扩展名为.py的python文件。那么如何使用模块中的函数呢？<br> </p><pre class="line-numbers language-none"><code class="language-none">import pizzapizza.make_pizza(16, 'pepperoni')pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>  或者直接导入模块中的制定函数，这样就不需要通过点.操作去指明引用函数了。如下 -<br>  <pre class="line-numbers language-none"><code class="language-none">from pizza import make_pizzamake_pizza(16, 'pepperoni')make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>  as 关键字给函数指定别名，特别是当函数定义较长时，如下-<br>  <pre class="line-numbers language-none"><code class="language-none">from pizza import make_pizza as mpmp(16, 'pepperoni')mp(12, 'mushrooms', 'green peppers', 'extra cheese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>  当然，也可以这么直接导入所有的函数，只是系统开销会增加而已<p></p><blockquote><p>from pizza import *</p></blockquote><p>   另外 -<br>    &gt;编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下<br>    划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。<br>    &gt;所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整<br>    个程序。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Common Knowledge of Python - I</title>
      <link href="/2015/10/23/2018-10-23-the-common-knowledge-of-python-i/"/>
      <url>/2015/10/23/2018-10-23-the-common-knowledge-of-python-i/</url>
      
        <content type="html"><![CDATA[<p>学习任何一门语言，首先要了解它的基本语法，熟练的掌握语法是写好程序的首要条件，任何一种编程语言，它的语法架构有着惊人的相似，对于有一定编程基础的童鞋来说，学习Python真的很得心应手。这里我粗略梳理一下Python语言的基本要点，希望对系统了解这门语言有所裨益-</p><span id="more"></span><p><strong>1. 变量</strong></p><ul><li>和大多数语言一样，变量可由数字，字母和下划线组成，<font color="red">不能由数字打头。</font></li><li>不要使用Python的保留字作为变量名，以防止解释器编译错误，保留字就是Python内部有特殊意义和用途的字符串定义，如函数名print，变量名类型名int，str, if, while 等等。</li><li>变量名虽然没有强制规定大小写问题，但使用小写字母定义是个不错的主意，大多数语言都如此。</li></ul><p><strong>2. 数据类型</strong><br>Python数据类型有-</p><ul><li><p>字符串String（在Python中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号）</p></li><li><p>数字类型Number</p></li><li><p>列表List</p></li><li><p>元组Tuple</p></li><li><p>集合Sets</p></li><li><p>字典Dict<br>每种数据类型都有相应的计算规则，正式因为这些丰富的计算规则，才使得人们能通过它们实现多姿多彩的现实世界表述。</p></li><li><p><em>2.1 数值计算</em></p><pre class="line-numbers language-none"><code class="language-none">print("5+3=",5+3)print("5-3=",5-3)print("5*3=",5*3)print("除法得到浮点数 2/4=",2/4)print("除法得到整数 2//4=",2//4)print("取余 10%3=",10%3)print("乘方 4**2=",4**2)print("开方 4**0.5=",4**0.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>2.2 String(字符串)</em></p><pre class="line-numbers language-none"><code class="language-none">#元素是不可变的string="abcdefg"print(string)print(string[0])print(string[0:-1])#从头到尾print(string[2:])#从下标2开始到尾print(string[2:4])#从下标2到n-1  [m,n)print(string*2)#输出2次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>2.3 list(列表)</em></p><pre class="line-numbers language-none"><code class="language-none">#元素可变的listDemo=["aa",1,"bb",2]print(listDemo)print(listDemo[0])#输出下标0print(listDemo[2:])#从下标2开始到尾print(listDemo[1:3])#从下标2到n-1  [m,n)print(listDemo*2)#输出2次listDemo[0]="替换的"print(listDemo)#修改后的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>2.4 tuple(元组)</em></p><pre class="line-numbers language-none"><code class="language-none">#元素不可变的tupleDemo=("aa",1,"bb",2)print(tupleDemo)print(tupleDemo[0])#输出下标0print(tupleDemo[2:])#从下标2开始到尾print(tupleDemo[1:3])#从下标2到n-1  [m,n)print(tupleDemo*2)#输出2次tupleDemo=()#空元组tupleDemo=(a,)#一个元素print(tupleDemo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>2.5 Set(集合)</em></p><pre class="line-numbers language-none"><code class="language-none">#一个无序不可重复的序列setDemo={"a","b","c"}print("集合A ",setDemo)#集合可以做 交集并集差集setDemo2={"a","b"}print("集合B ",setDemo2)print("AB的差集 ",setDemo-setDemo2)print("AB的并集 ",setDemo|setDemo2)print("AB的交集 ",setDemo&amp;setDemo2)print("AB的不同时存在的 ",setDemo^setDemo2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>2.6 字典</em></p><pre class="line-numbers language-none"><code class="language-none">dictDemo={"tom":"90","jerry":"75"}print(dictDemo)print(dictDemo["tom"])print("keys:",dictDemo.keys())print("values",dictDemo.values())#移除 key 返回valueprint("移除tom ",dictDemo.pop("tom"))print(dictDemo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em><strong>python常用数据转换</strong></em><br>‘’’<br>int(x)<br>str(x)<br>tuple(s) 将序列转换成元组<br>list(s) 将序列转换成列表<br>‘’’</p></li><li><p><strong>python的注释</strong><br>print(“单行注释 #”)<br>print(“多行注释 单引号(3个’)”)<br>print(“多行注释 双引号(3个双引号)”)</p></li></ul><p><strong>3. 判断及循环语句</strong></p><ul><li>3.1 Python里的判断语句主要指if或if。。。else组合语句，常见形式有：<pre class="line-numbers language-none"><code class="language-none">if condition:  pass或者if conditon:  passelse:  pass或者if condition：  passelif condition1：  passelif condition2：  pass。。。else：  pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这些用起来很简单, 条件简单时用if或if。。。else；多重条件判断时用if。。elif。。elif 。。。组合。</li></ul><ul><li>3.2 循环语句有-<br>for循环-<pre class="line-numbers language-none"><code class="language-none">for each in string/list/tuple/dict:  passfor key, value in dict.items():  passorfor key, value in dict：  pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>‘in’后面是pytho集合数据类型，常见的有list， tuple， dict，string，而数据列表常会用range（）函数来实现。<br>while循环-<pre class="line-numbers language-none"><code class="language-none">prompt = "\nTell me something, and I will repeat it back to you:"prompt += "\nEnter 'quit' to end the program. "active = Truewhile active:  message = input(prompt)  if message == 'quit':    active = False  else:    print(message)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>在任何Python循环中都可使用break语句。例如，可使用break语句来退出遍历列表或字典的for循环。</li></ul><ul><li>while循环通常用于处理列表和字典的元素，在列表元素不断变化时，用while比用for更好控制和跟踪。</li></ul><ul><li>在任何Python循环语句中都可以使用continue语句，程序执行到continue语句时会忽略本次循环未执行的代码，进入下一轮循环。</li></ul><p><strong>4. 复合数据的嵌套</strong><br>  这里主要介绍下字典，列表之间的嵌套关系，也就是说这类复合数据元素可以相互嵌套，即列表中的元素可以是字典，字典中的元素可以是列表，以及它们之间的相互嵌套关系。下面来看几个例子 -</p><ul><li>4.1 列表字典（列表中的元素为字典的嵌套数据）<pre class="line-numbers language-none"><code class="language-none">perChar = {'Sexual': 'Female', 'Company':'Appl.', 'Work Location':'Shanghai', 'JobLevel':'SSE'}addList = []for i in range(20):    addList.append(perChar)for j in addList:    print j# 修改字典元素的值for j in addList[0:10]:    if j['Work Location'] == 'Shanghai':        j['Work Location'] = 'ChongQing'        j['JobLevel'] = 'INT'print "#" * 58for j in addList:    print jprint "打印第二个列表元素", addList[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>4.2 字典列表（字典中的元素为列表的嵌套数据）<pre class="line-numbers language-none"><code class="language-none">pizza = {'crust': 'thick', 'topping':['hot', 'meaty', 'spicy']}print "What would you like the pizaa?\nI'd like the pizza :", pizza['crust'], "\nand the topping had better like these -"for top in pizza['topping']:    print top<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>4.3 字典中嵌套字典的数据<pre class="line-numbers language-none"><code class="language-none">users = {'Alan':{'fullName':'Alan_yuan', 'Job':'SW QA Expert', 'Location':'Shanghai', 'Sex':'Male'}, 'Wendy':{'fullName':'Wendy_zhang', 'Job':'Chemicle Scientist', 'Location':'Shanghai', 'Sex':'Female'} }print "Please show me the user information\n"for name, info in users.items():    print "User Name:", name    information = "全名：" + info['fullName'] + " 工作：" + info['Job'] + " 工作地：" + info['Location'] + " 性别：" + info['Sex']    print "And his/her information are -", information<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  到此为止，我们已经梳理了Python的常用数据，以及循环和控制语句的基本知识点，牢记这些，在工作中加以练习，举一反三，就能做到熟能生巧了，下面的一篇blog将接着梳理Python的其他一些知识点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试流程</title>
      <link href="/2015/09/24/2018-09-24-zi-dong-hua-ce-shi-liu-cheng/"/>
      <url>/2015/09/24/2018-09-24-zi-dong-hua-ce-shi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h6 id="什么时候需要自动化测试"><a href="#什么时候需要自动化测试" class="headerlink" title="什么时候需要自动化测试"></a><font color="red">什么时候需要自动化测试</font></h6><p>这个问题几乎每个学习自动化的人都会遇到，答案也是各不相同，但问题本质上离不开这几个因素：</p><ul><li>1.&gt;    Test Times – if you often required to do regression test</li><li>2.&gt;    Test Environment – if the test environment is stable</li><li>3.&gt;    Reusable Repeat Operation – if your projects have the large of reusable repeat operation</li><li>4.&gt;    Project release frequency – if your project is a long term project and if the release is frequency</li><li>5.&gt;    Effort Measure – if the effort is measurable/calculate between manual and automation</li></ul><span id="more"></span><p>基本上如果一个项目满足这些必要条件，那么自动化测试的优势就会比较明显，这也是衡量我们是否导入自动化测试的一个前置判断。另外，通过上面的分析，我们也很容易得出自动化测试的优缺点 –</p><p>The merit of using Automation Test</p><ul><li>1.&gt;    It’s more convenient for regression test</li><li>2.&gt;    It’s more quickly and efficiently to run the complex cases</li><li>3.&gt;    It can take advantage of the resources well and make the people pay more attention to the jobs that more needs manual focus on</li><li>4.&gt;     Reduce the mistakes of human caused</li><li>5.&gt;    More accurate to simulate the manual test</li><li>6.&gt;    Save effort</li></ul><p>The demerit of Automation</p><ul><li>1.&gt;    Automation不能完全代替Manual</li><li>2.&gt;    Manual test 必定会比自动化测试发现更多的bug</li><li>3.&gt;    自动化测试对环境和相关前置条件的依赖比较大</li><li>4.&gt;    自动化测试没有Manual测试的想象空间大</li><li>5.&gt;    不要奢望自动化测试能帮助你发现所有的问题</li></ul><h6 id="自动化测试流程"><a href="#自动化测试流程" class="headerlink" title="自动化测试流程"></a><font color="red">自动化测试流程</font></h6><p>什么是自动化的测试流程？这也是每个学习自动化测试的人员必须面对和回答的问题， 做任何事情都必须遵循一定的准则。 自动化测试流程的作用就在如此。它是指导自动化测试的总体原则和自动化工作展开的参考依据。那么什么是自动化测试流程呢？简言之，如下图（图1-1自动化测试示意图）</p><p>图1-1 自动化测试示意图<br><img src="/medias/automationFlow.GIF" alt="自动化测试流程图"></p><pre class="line-numbers language-none"><code class="language-none">st=&gt;start: starte=&gt;end: endingop1=&gt; operation: caozuost-&gt;op1-&gt;e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试实用参考</title>
      <link href="/2015/09/10/2018-11-19-zi-dong-hua-ce-shi-shi-yong-can-kao/"/>
      <url>/2015/09/10/2018-11-19-zi-dong-hua-ce-shi-shi-yong-can-kao/</url>
      
        <content type="html"><![CDATA[<p><span><font color="red" size="10/">自<font color="yellow" size="9/">动<font color="blue" size="8/">化</font></font></font></span><font color="red" size="10/"><font color="yellow" size="9/"><font color="blue" size="8/"> <span><font color="black" size="3"> 在软件测试中的应用已呈现出百花争艳，欣欣向荣的发展势态，自动化测试理论也随着软件行业的蓬勃发展而日期完善，被越来越多的用户所接受，围绕自动化测试的工具和平台如今数不胜数，技术的发展总是在需要改进的地方不期而遇，这也造就了今天自动化测试的大好局面，在自动化测试的道路上，你一定听说过HP的大名，他就像江湖里的传说，虽然久远却一直在线，今天在这里分享一些我曾经做过的自动化测试案例，主要依赖的平台工具就是基于HP的QTP，UFT套件，希望这对有兴趣的你有所帮助！文章有点长，建议先下载再研读 - </font></span><font color="black" size="3"><br><img src="/medias/cover.jpg" alt="自动化测试参考"><br><a href="/medias/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E7%94%A8%E5%8F%82%E8%80%83.pdf">正文</a></font></font></font></font></p><font color="red" size="10/"><font color="yellow" size="9/"><font color="blue" size="8/"><font color="black" size="3"></font></font></font></font>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
          <category> QTP/UFT </category>
          
          <category> LR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> LR </tag>
            
            <tag> QTP/UFT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
